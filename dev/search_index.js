var documenterSearchIndex = {"docs":
[{"location":"about/julia-intro/#julia-intro","page":"Introduction to Julia","title":"Introduction to Julia","text":"","category":"section"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"You can learn all the basics of Julia from the official documentation but as this is quite a lot to read, here are a few key points.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"First of all, you may have noticed that the first time you call a function like partitions(3) it takes a bit of time to get an answer—but the second time you call it the answer is immediate. This is because Julia uses just-in-time (JIT) compilation, which means it compiles code at run time just before it is actually needed. This is part of what makes Julia so fast—with the trade-off that there will be a delay in the first call of a function.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Second, there are two—but likely more—caveats for algebraists in Julia: integers are by default 64-bit integers (on a 64-bit machine) and division is floating point division:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"julia> 2^64\n0\njulia> typeof(2)\nInt64\njulia> 6/9\n0.6666666666666666\njulia> typeof(6/9)\nFloat64","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"This is of course not what we want. As an algebraist working with Julia you always have to keep in mind:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"warning: Warning\nJulia was designed with applications in numerics in mind.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"But we can fix this! First, notice from the example above that every object in Julia is of a certain type, e.g. Int64 in case of the number 2. An object of a type called MyType can be created from input data required by this type by calling MyType(...), where the dots represent the input data. For example, Julia provides the type BigInt for big integers (based on the GMP library) and we can create big integers as follows:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"julia> a = BigInt(2)\n2\njulia> typeof(a)\nBigInt\njulia> a^64\n18446744073709551616","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Much better! There is more to say about integers but we'll come back to this in the next section.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Typically, names of types start with an uppercase letter while names of functions start with a lowercase letter. The operator for exact division in Julia is the double slash //:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"julia> x = 6//9\n2//3\njulia> typeof(x)\nRational{Int64}","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"You see that there is a type Rational for (exact) rational numbers in Julia. This type is actually a parametric type Rational{T} which means that it refers to rational numbers created from integers of type T—in this case 64-bit integers. I'll leave it to you to find out the type of a division of two big integers.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"You can implement your own types, e.g. here is how I implemented a type for partitions:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"struct Partition{T} <: AbstractArray{T,1}\n    p::Array{T,1}\nend","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"This means that Partition{T} is a parametric subtype of AbstractArray{T,1}, the latter being the parametric type of (abstract) one-dimensional arrays. The array is internally stored in the field called p and this field will be filled by the type constructor:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"julia> P = Partition([6,4,3,1]);\njulia> typeof(P)\nPartition{Int64}\njulia> P.p\n4-element Vector{Int64}:\n 6\n 4\n 3\n 1","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"As you can see in the partition type example, you can build up a hierarchy—a tree—of types but it is important to note that only the leaves of this tree can be instantiated: there is a distinction between concrete types (the leaves) and abstract types (everything else). If you want to know more about types, you should read the section about types in the Julia documentation.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Functions in Julia are implemented in such a way that one specifies the type of the parameters, there is a function to obtain the conjugate of a partition and this looks like:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"function conjugate(P::Partition{T}) where T<:Integer\n    #some code\nend","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Let's try it in the above example:","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"julia> conjugate(P)\n[4, 3, 3, 2, 1, 1]","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"Beautiful. Now, one of the backbones of Julia is that you can implement a separate function with the same name conjugate but acting on a different type in a different way. This concept is called multiple dispatch. Using types and multiple dispatch one can model mathematical structures roughly to how one abstractly thinks about them and this is another very good reason why Julia is a great choice for modern computer algebra.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"warning: Warning\nRecall that Julia structures form a tree of which only the leaves can be instantiated. Structures in the mathematical world, however, do not form the leaves of a tree, e.g. an algebra over a field is both a vector space and a ring. Therefore, you should not think of types as the ultimate way to go for modeling all sorts of mathematical structures in general. Types should be used to implement structures for which one can implement generic code.","category":"page"},{"location":"about/julia-intro/","page":"Introduction to Julia","title":"Introduction to Julia","text":"A further important aspect of Julia is that one can create packages (like JuLie) and use everything from any other package as well. You can use JuLie as a template for your own package (see also the additional information in the section on contributing to learn some basics about developing in Julia).","category":"page"},{"location":"combinatorics/tableaux/#Tableaux","page":"Tableaux","title":"Tableaux","text":"","category":"section"},{"location":"combinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"Tableau","category":"page"},{"location":"combinatorics/tableaux/#JuLie.Tableau","page":"Tableaux","title":"JuLie.Tableau","text":"Tableau{T} <: AbstractArray{AbstractArray{T,1},1}\n\nA Young diagram is a diagram of finitely many empty \"boxes\" arranged in left-justified rows, with the row lengths in non-increasing order. The box in row i and and column j has the coordinates (i,j). Listing the number of boxes in each row gives a partition λ of a non-negative integer n (the total number of boxes of the diagram). The diagram is then said to be of shape λ. Conversely, one can associate to any partition λ a Young diagram in the obvious way, so Young diagrams are just another way to look at partitions.\n\nA Young tableau of shape λ is a filling of the boxes of the Young diagram of λ with elements from some set. After relabeling we can (and will) assume that we fill from a set of integers from 1 up to some number, which in applications is often equal to n. We encode a tableau as an array of arrays and we have implemented an own type Tableau{T}\tas subtype of AbstractArray{AbstractArray{T,1},1} to work with tableaux. As for partitions, you may increase performance by casting into smaller integer types, e.g.\n\nFor efficiency, we do not check whether the given array is really a tableau, i.e. whether the structure of the array defines a partition.\n\nExample\n\njulia> Tab=Tableau([[1,2,3],[4,5],[6]])\njulia> Tab=Tableau(Array{Int8,1}[[2,1], [], [3,2,1]]) #Using 8 bit integers\n\nReferences\n\nWikipedia, Young tableau.\n\n\n\n\n\n","category":"type"},{"location":"combinatorics/tableaux/#Operations","page":"Tableaux","title":"Operations","text":"","category":"section"},{"location":"combinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"hook_length\nhook_lengths\nshape\nweight\nreading_word","category":"page"},{"location":"combinatorics/tableaux/#JuLie.hook_length","page":"Tableaux","title":"JuLie.hook_length","text":"hook_length(lambda::Partition, i::Integer, j::Integer)\n\nConsider the Young diagram of a partition λ. The hook length of a box, is the number of boxes to the right in the same row + the number of boxes below in the same column + 1. The function returns the hook length of the box with coordinates (i,j). The functions assumes that the box exists.\n\n\n\n\n\nhook_length(Tab::Tableau, i::Integer, j::Integer)\n\nShortcut for hook_length(shape(Tab),i,j).\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.hook_lengths","page":"Tableaux","title":"JuLie.hook_lengths","text":"hook_lengths(lambda::Partition)\n\nReturns the tableau of shape λ in which the entry at position (i,j) is equal to the hook length of the corresponding box.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.shape","page":"Tableaux","title":"JuLie.shape","text":"shape(Tab::Tableau{T})\n\nReturns the shape of a tableau, i.e. the partition given by the lengths of the rows of the tableau.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.weight","page":"Tableaux","title":"JuLie.weight","text":"weight(Tab::Tableau)\n\nThe weight of a tableau is the number of times each number appears in the tableau. The return value is an array whose i-th element gives the number of times the integer i appears in the tableau.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.reading_word","page":"Tableaux","title":"JuLie.reading_word","text":"reading_word(Tab::Tableau)\n\nThe reading word of a tableau is the word obtained by concatenating the fillings of the rows, starting from the bottom row. The word is here returned as an array.\n\nExample\n\njulia> reading_word(Tableau([ [1,2,3] , [4,5] , [6] ]))\n6-element Array{Int64,1}:\n 6\n 4\n 5\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#Semistandard-tableaux","page":"Tableaux","title":"Semistandard tableaux","text":"","category":"section"},{"location":"combinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"is_semistandard\nsemistandard_tableaux","category":"page"},{"location":"combinatorics/tableaux/#JuLie.is_semistandard","page":"Tableaux","title":"JuLie.is_semistandard","text":"is_semistandard(Tab::Tableau)\n\nA tableau is called semistandard if the entries weakly increase along each row and strictly increase down each column.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.semistandard_tableaux","page":"Tableaux","title":"JuLie.semistandard_tableaux","text":"semistandard_tableaux(shape::Partition{T}, max_val=sum(shape)::Integer) where T<:Integer\n\nReturns a list of all semistandard tableaux of given shape and filling elements bounded by max_val. By default, max_val is equal to the sum of the shape partition (the number of boxes in the Young diagram). The list of tableaux is in lexicographic order from left to right and top to bottom.\n\n\n\n\n\nsemistandard_tableaux(shape::Partition{T}, max_val=sum(shape)::Integer) where T<:Integer\n\nShortcut for semistandard_tableaux(Partition(shape),max_val).\n\n\n\n\n\nsemistandard_tableaux(box_num::T, max_val=box_num::T) where T<:Integer\n\nReturns a list of all semistandard tableaux consisting of box_num boxes and filling elements bounded by max_val.\n\n\n\n\n\nsemistandard_tableaux(s::Array{T,1}, weight::Array{T,1}) where T<:Integer\n\nReturns a list of all semistandard tableaux with shape s and given weight. This requires that sum(s) = sum(weight).\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#Standard-tableaux","page":"Tableaux","title":"Standard tableaux","text":"","category":"section"},{"location":"combinatorics/tableaux/","page":"Tableaux","title":"Tableaux","text":"is_standard\nstandard_tableaux\nnum_standard_tableaux\nschensted\nbump!","category":"page"},{"location":"combinatorics/tableaux/#JuLie.is_standard","page":"Tableaux","title":"JuLie.is_standard","text":"is_standard(Tab::Tableau)\n\nA tableau is called standard if it is semistandard and the entries are in bijection with 1,…,n, where n is the number of boxes.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.standard_tableaux","page":"Tableaux","title":"JuLie.standard_tableaux","text":"standard_tableaux(s::Partition)\nstandard_tableaux(s::Array{Integer,1})\n\nReturns a list of all standard tableaux of a given shape.\n\n\n\n\n\nstandard_tableaux(n::Integer)\n\nReturns a list of all standard tableaux with n boxes.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.num_standard_tableaux","page":"Tableaux","title":"JuLie.num_standard_tableaux","text":"num_standard_tableaux(lambda::Partition)\n\nReturns the number f^lambda of standard tableaux of shape λ using the hook length formula\n\nf^lambda = fracnprod_ij h_lambda(ij) \n\nwhere the product is taken over all boxes in the Young diagram of lambda and h_lambda denotes the hook length of the box (i,j).\n\nReferences\n\nWikipedia, Hook length formula.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.schensted","page":"Tableaux","title":"JuLie.schensted","text":"schensted(sigma::Array{Integer,1})\nschensted(sigma::Perm{T})\n\nThe Robinson–Schensted correspondence is a bijection between permutations and pairs of standard Young tableaux of the same shape. For a permutation sigma (given as an array), this function performs the Schnested algorithm and returns the corresponding pair of standard tableaux (the insertion and recording tableaux).\n\nExample\n\njulia> P,Q = schensted([3,1,6,2,5,4]);\njulia> P\n[[1, 2, 4], [3, 5], [6]]\n\njulia> Q\n[[1, 3, 5], [2, 4], [6]]\n\nReferences\n\nWikipedia, Robinson–Schensted correspondence\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/tableaux/#JuLie.bump!","page":"Tableaux","title":"JuLie.bump!","text":"bump!(Tab::Tableau, x::Int)\n\nInserts the integer x into the tableau Tab according to the bumping algorithm by applying the Schensted insertion.\n\nReferences\n\nWolfram MathWorld, Bumping Algorithm\n\n\n\n\n\nbump!(Tab::Tableau, x::Integer, Q::Tableau, y::Integer)\n\nInserts x into Tab according to the bumping algorithm by applying the Schensted insertion. Traces the change with Q by inserting y at the same Position in Q as x in Tab.\n\n\n\n\n\n","category":"function"},{"location":"julie-index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"julie-index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"about/motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"about/motivation/","page":"Motivation","title":"Motivation","text":"The ultimate goal of JuLie is to help finding new results in (and around) representation theory. Since there's a lot already in other computer algebra systems (like GAP, Magma, and Sage), it may seem absurd to start a new project and not simply build on the existing systems. But there is a very good reason: the programming language Julia which was introduced in 2012 (see also the Wikipedia article). The advantages of Julia—that may not all exist to such an extend in other systems—are the following:","category":"page"},{"location":"about/motivation/","page":"Motivation","title":"Motivation","text":"Through its type system and multiple dispatch it is possible to model mathematical structures roughly in the same way you think about them abstractly (this is what I mean by \"mathematically sound\").\nIt is very fast and memory efficient (see the benchmarks of JuLie).\nIt has a straightforward high-level syntax that makes code easy to write and read.\nIt is open source and community-driven.\nIt is modern.","category":"page"},{"location":"about/motivation/","page":"Motivation","title":"Motivation","text":"These points speak in favor of using Julia as basis for modern computer algebra and this is precisely the motivation of the OSCAR project started in 2017 (see also my overview). JuLie may be considered as a contribution to OSCAR in the field of representation theory (which in turn is another motivation for JuLie).","category":"page"},{"location":"about/motivation/","page":"Motivation","title":"Motivation","text":"One \"milestone\" of JuLie is to implement \"all\" the material from (and as in) the book Introduction to Soergel bimodules by B. Elias, S. Makisumi, U. Thiel, and G. Williamson. Of course, anything else is always welcome: please contribute!","category":"page"},{"location":"combinatorics/partitions/#Partitions","page":"Partitions","title":"Partitions","text":"","category":"section"},{"location":"combinatorics/partitions/","page":"Partitions","title":"Partitions","text":"Partition","category":"page"},{"location":"combinatorics/partitions/#JuLie.Partition","page":"Partitions","title":"JuLie.Partition","text":"Partition{T} <: AbstractArray{T,1}\n\nA partition of an integer n ≥ 0 is a decreasing sequence λ=(λ₁,…,λᵣ) of positive integers λᵢ whose sum is equal to n. The λᵢ are called the parts of the partition. We encode a partition as an array with elements λᵢ. You may increase performance by using smaller integer types, see the examples below. For efficiency, the Partition constructor does not check whether the given array is in fact a partition, i.e. a decreasing sequence.\n\nExamples\n\njulia> P=Partition([3,2,1]) #The partition 3+2+1 of 6\n[3, 2, 1]\njulia> sum(P) #The sum of the parts.\n6\njulia> P[1] #First component\n3\njulia> P=Partition(Int8[3,2,1]) #Same partition but using 8 bit integers\n\nRemarks\n\nUsually, |λ| ≔ n is called the size of λ. In Julia, the function size for arrays already exists and returns the dimension of an array. Instead, you can use the Julia function sum to get the sum of the parts.\nThere is no performance impact by using an own type for partitions rather than simply using arrays—and this is of course much cleaner. The implementation of a subtype of AbstractArray is explained in the Julia documentation.\n\nReferences\n\nWikipedia, Partition (number theory)\n\n\n\n\n\n","category":"type"},{"location":"combinatorics/partitions/#Unrestricted-partitions","page":"Partitions","title":"Unrestricted partitions","text":"","category":"section"},{"location":"combinatorics/partitions/","page":"Partitions","title":"Partitions","text":"partitions(::Integer)\nnum_partitions(::Integer)\nascending_partitions","category":"page"},{"location":"combinatorics/partitions/#JuLie.partitions-Tuple{Integer}","page":"Partitions","title":"JuLie.partitions","text":"partitions(n::Integer)\n\nA list of all partitions of an integer n ≥ 0, produced in lexicographically descending order. This ordering is like in Sage, but opposite to GAP. You can apply the function reverse to reverse the order. As usual, you may increase performance by using smaller integer types. The algorithm used is \"Algorithm ZS1\" by Zoghbi & Stojmenovic (1998).\n\nExamples\n\njulia> partitions(Int8(10)) #Using 8-bit integers\n\nReferences\n\nZoghbi, A. & Stojmenovic, I. (1998). Fast algorithms for generating integer partitions. Int. J. Comput. Math., 70(2), 319–332. https://doi.org/10.1080/00207169808804755\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/partitions/#JuLie.num_partitions-Tuple{Integer}","page":"Partitions","title":"JuLie.num_partitions","text":"num_partitions(n::Integer)\nnum_partitions(n::fmpz)\n\nThe number of integer partitions of the integer n ≥ 0. Uses the function from FLINT, which is very fast.\n\nReferences\n\nThe On-Line Encyclopedia of Integer Sequences, A000041\nFLINT, Number of partitions\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/partitions/#JuLie.ascending_partitions","page":"Partitions","title":"JuLie.ascending_partitions","text":"ascending_partitions(n::Integer;alg=\"ks\")\n\nInstead of encoding a partition of an integer n ≥ 0 as a descending sequence (which is our convention), one can also encode it as an ascending sequence. In the papers Kelleher & O'Sullivan (2014) and Merca (2012) it is said that generating the list of all ascending partitions is more efficient than generating descending ones. To test this, I have implemented the algorithms given in the papers:\n\n\"ks\" (default) is the algorithm \"AccelAsc\" (Algorithm 4.1) in Kelleher & O'Sullivan (2014).\n\"m\" is Algorithm 6 in Merca (2012). This is actually similar to \"ks\".\n\nThe ascending partitions are stored here as arrays and are not of type Partition since the latter are descending by our convention. I am using \"ks\" as default since it looks slicker and I believe there is a tiny mistake in the publication of \"m\" (which I fixed).\n\nComparison\n\nI don't see a significant speed difference to the descending encoding:\n\njulia> @btime partitions(Int8(90));\n    3.376 s (56634200 allocations: 6.24 GiB)\n\njulia> @btime ascending_partitions(Int8(90),alg=\"ks\");\n    3.395 s (56634200 allocations: 6.24 GiB)\n\njulia> @btime ascending_partitions(Int8(90),alg=\"m\");\n    3.451 s (56634200 allocations: 6.24 GiB)\n\nReferences\n\nKelleher, J. & B., O'Sullivan (2014). Generating All Partitions: A Comparison Of Two Encodings. arXiv:0909.2331v2. https://arxiv.org/abs/0909.2331\nMerca, M. (2012). Fast algorithm for generating ascending compositions. J. Math. Model. Algorithms, 11(1), 89–104. https://doi.org/10.1007/s10852-011-9168-y\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/partitions/#Restricted-partitions","page":"Partitions","title":"Restricted partitions","text":"","category":"section"},{"location":"combinatorics/partitions/","page":"Partitions","title":"Partitions","text":"partitions(::Integer, ::Integer, ::Integer, ::Integer)\npartitions(::Integer, ::Integer)\nnum_partitions(::Integer, ::Integer)\npartitions(::Array{Integer,1}, ::Integer, ::Array{Integer,1}, ::Integer)","category":"page"},{"location":"combinatorics/partitions/#JuLie.partitions-NTuple{4,Integer}","page":"Partitions","title":"JuLie.partitions","text":"partitions(m::Integer, n::Integer, l1::Integer, l2::Integer; z=0)\n\nA list of all partitions of an integer m ≥ 0 into n ≥ 0 parts with lower bound l1 ≥ 0 and upper bound l2 ≥ l1 for the parts. There are two choices for the parameter z:\n\nz=0: no further restriction (default);\nz=1: only distinct parts.\n\nThe partitions are produced in decreasing order.\n\nThe algorithm used is \"parta\" in Riha & James (1976), de-gotoed from old ALGOL code by E. Thiel!\n\nReferences\n\nRiha, W. & James, K. R. (1976). Algorithm 29 efficient algorithms for doubly and multiply restricted partitions. Computing, 16, 163–168. https://link.springer.com/article/10.1007/BF02241987\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/partitions/#JuLie.partitions-Tuple{Integer,Integer}","page":"Partitions","title":"JuLie.partitions","text":"partitions(m::Integer, n::Integer)\n\nAll partitions of an integer m ≥ 0 into n ≥ 1 parts (no further restrictions).\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/partitions/#JuLie.num_partitions-Tuple{Integer,Integer}","page":"Partitions","title":"JuLie.num_partitions","text":"num_partitions(n::Integer, k::Integer)\nnum_partitions(n::fmpz, k::fmpz)\n\nThe number of integer partitions of the integer n ≥ 0 into k ≥ 0 parts. The implementation uses a recurrence relation.\n\nReferences\n\nThe On-Line Encyclopedia of Integer Sequences, A008284\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/partitions/#JuLie.partitions-Tuple{Array{Integer,1},Integer,Array{Integer,1},Integer}","page":"Partitions","title":"JuLie.partitions","text":"partitions(mu::Array{Integer,1}, m::Integer, v::Array{Integer,1}, n::Integer)\n\nAll partitions of an integer m >= 0 into n >= 1 parts, where each part is an element in v and each v[i] occurs a maximum of mu[i] times. The partitions are produced in    decreasing order. The algorithm used is a de-gotoed version (by E. Thiel!) of algorithm \"partb\" in Riha & James (1976).\n\nRemark\n\nThe original algorithm lead to BoundsErrors, since r could get smaller than 1. Furthermore x and y are handled as arrays with an infinite length. After finding all valid partitions, the algorithm will continue searching for partitions of length n+1. We thus had to add a few additional checks and interruptions. Done by T. Schmit.\n\nReferences\n\nRiha, W. & James, K. R. (1976). Algorithm 29 efficient algorithms for doubly and multiply restricted partitions. Computing, 16, 163–168. https://link.springer.com/article/10.1007/BF02241987\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/partitions/#Operations","page":"Partitions","title":"Operations","text":"","category":"section"},{"location":"combinatorics/partitions/","page":"Partitions","title":"Partitions","text":"conjugate\ngetindex_safe","category":"page"},{"location":"combinatorics/partitions/#JuLie.conjugate","page":"Partitions","title":"JuLie.conjugate","text":"conjugate(λ::Partition{T}) where T<:Integer\n\nThe conjugate of a partition is obtained by considering its Young diagram (see Tableaux) and then flipping it along its main diagonal.\n\nReferences\n\nWikipedia, Partition (number theory)\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/partitions/#JuLie.getindex_safe","page":"Partitions","title":"JuLie.getindex_safe","text":"getindex_safe(P::Partition, i::Int)\n\nIn algorithms involving partitions it is sometimes convenient to be able to access parts beyond the length of the partition, and then you want to get zero instead of an error. This function is a shortcut for\n\nreturn (i>length(P.p) ? 0 : getindex(P.p,i))\n\nIf you are sure that P[i] exists, use getindex because this will be faster.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/partitions/#Relations","page":"Partitions","title":"Relations","text":"","category":"section"},{"location":"combinatorics/partitions/","page":"Partitions","title":"Partitions","text":"dominates","category":"page"},{"location":"combinatorics/partitions/#JuLie.dominates","page":"Partitions","title":"JuLie.dominates","text":"dominates(λ::Partition, μ::Partition)\n\nThe dominance order on partitions is the partial order ⊵ defined by λ ⊵ μ if and only if λ₁ + … + λᵢ ≥ μ₁ + … + μᵢ for all i. This function returns true if λ ⊵ μ.\n\nReferences\n\nWikipedia, Dominance order\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#Combinatorial-functions","page":"Combinatorial functions","title":"Combinatorial functions","text":"","category":"section"},{"location":"combinatorics/combinatorial-functions/","page":"Combinatorial functions","title":"Combinatorial functions","text":"This section is about basic combinatorial functions that arise in the context of counting problems. Usually, there are indirect ways of counting—like closed formulas—instead of having to explicitly create the list of objects in question. More special combinatorial functions that count objects we have implemented (e.g. restricted partitions) are discussed in the respective sections.","category":"page"},{"location":"combinatorics/combinatorial-functions/","page":"Combinatorial functions","title":"Combinatorial functions","text":"bell\nbinomial\ncatalan\neuler\nfactorial\nlucas\nstirling1\nstirling2","category":"page"},{"location":"combinatorics/combinatorial-functions/#Nemo.bell","page":"Combinatorial functions","title":"Nemo.bell","text":"bell(n::T) where T<:Union{Int,fmpz}\n\nThe n-th Bell number Bₙ. This counts the number of partitions of an n-element set.\n\nThe implementation is the one from Nemo which in turn uses the one from FLINT.\n\nRefences\n\nWikipedia, Bell number\nThe On-Line Encyclopedia of Integer Sequences, A000110\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#Base.binomial","page":"Combinatorial functions","title":"Base.binomial","text":"binomial(n::T, k::T) where T<:Union{Int,fmpz}\n\nThe binomial coefficient n choose k. This counts the number of k-element subsets of an n-element set.\n\nFor type fmpz the implementation is the one from Nemo which in turn uses the one from FLINT.\n\nRefences\n\nWikipedia, Binomial coefficient\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#JuLie.catalan","page":"Combinatorial functions","title":"JuLie.catalan","text":"catalan(n::fmpz)\ncatalan(n::Integer)\n\nThe n-th Catalan number Cₙ. This counts all sorts of things, e.g. the number of expressions containing n pairs of parentheses which are correctly matched.\n\nThe computation simply uses the formula\n\nC_n = frac1n+1 2n choose n \n\nRefences\n\nWikipedia, Catalan number\nThe On-Line Encyclopedia of Integer Sequences, A000108\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#JuLie.euler","page":"Combinatorial functions","title":"JuLie.euler","text":" euler(n::fmpz)\n euler(n::Integer)\n\nThe n-th Euler number. The implementation is a wrapper to FLINT.\n\nReferences\n\nWikipedia, Euler numbers\nThe On-Line Encyclopedia of Integer Sequences, A122045\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#Base.factorial","page":"Combinatorial functions","title":"Base.factorial","text":"factorial(n::T) where T<:Union{Int,fmpz}\n\nThe factorial of n. This counts the number of permuations of n distinct objects.\n\nFor type fmpz the implementation is the one from Nemo which in turn uses the one from FLINT.\n\nRefences\n\nWikipedia, Factorial\nThe On-Line Encyclopedia of Integer Sequences, A000142\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#JuLie.lucas","page":"Combinatorial functions","title":"JuLie.lucas","text":"lucas(n::fmpz)\nlucas(n::Integer)\n\nThe n-th Lucas number. The implementation is a wrapper to the function in GMP.\n\nReferences\n\nWikipedia, Lucas number\nThe On-Line Encyclopedia of Integer Sequences, A000032\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#JuLie.stirling1","page":"Combinatorial functions","title":"JuLie.stirling1","text":"stirling1(n::fmpz, k::fmpz)\nstirling1(n::Integer, k::Integer)\n\nThe Stirling number S₁(n,k) of the first kind. The absolute value of S₁(n,k) counts the number of permutations of n elements with k disjoint cycles. The implementation is a wrapper to the function in FLINT.\n\nReferences\n\nWikipedia, Stirling numbers of the first kind\nThe On-Line Encyclopedia of Integer Sequences, A008275\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/combinatorial-functions/#JuLie.stirling2","page":"Combinatorial functions","title":"JuLie.stirling2","text":"stirling2(n::fmpz, k::fmpz)\nstirling2(n::Integer, k::Integer)\n\nThe Stirling number S₂(n,k) of the second kind. This counts the number of partitions of an n-element set into k non-empty subsets. The implementation is a wrapper to the function in FLINT.\n\nReferences\n\nWikipedia, Stirling numbers of the second kind\nThe On-Line Encyclopedia of Integer Sequences, A008277\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/multipartitions/#Multipartitions","page":"Multipartitions","title":"Multipartitions","text":"","category":"section"},{"location":"combinatorics/multipartitions/","page":"Multipartitions","title":"Multipartitions","text":"Multipartition\nmultipartitions\nnum_multipartitions","category":"page"},{"location":"combinatorics/multipartitions/#JuLie.Multipartition","page":"Multipartitions","title":"JuLie.Multipartition","text":"Multipartition{T} <: AbstractArray{Partition{T},1}\n\nMultipartitions are generalizations of partitions. An r-component multipartition of an integer n is an r-tuple of partitions λ¹, λ², …, λʳ where each λⁱ is a partition of some integer nᵢ ≥ 0 and the nᵢ sum to n.\n\nMultipartitions are implemented as a subtype of 1-dimensional arrays of partitions. You can use smaller integer types to increase performance.\n\nExamples\n\njulia> P=Multipartition( [[2,1], [], [3,2,1]] )\nPartition{Int64}[[2, 1], [], [3, 2, 1]]\njulia> sum(P)\n9\njulia> P[2]\nInt64[]\njulia> P=Multipartition( Array{Int8,1}[[2,1], [], [3,2,1]] )\nPartition{Int8}[[2, 1], [], [3, 2, 1]]\n\nReferences\n\nWikipedia, Multipartition\n\n\n\n\n\n","category":"type"},{"location":"combinatorics/multipartitions/#JuLie.multipartitions","page":"Multipartitions","title":"JuLie.multipartitions","text":"multipartitions(n::T, r::Integer) where T<:Integer\n\nA list of all r-component multipartitions of n. The algorithm is recursive and  based on partitions(::Integer).\n\nExample\n\njulia> multipartitions(2,2)\n5-element Vector{Multipartition{Int64}}:\n Partition{Int64}[[], [2]]\n Partition{Int64}[[], [1, 1]]\n Partition{Int64}[[1], [1]]\n Partition{Int64}[[2], []]\n Partition{Int64}[[1, 1], []]\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/multipartitions/#JuLie.num_multipartitions","page":"Multipartitions","title":"JuLie.num_multipartitions","text":"num_multipartitions(n::Int, k::Int)\n\nThe number of multipartitions of n into k parts is equal to\n\nsum_a=1^k k choose a sum_λ p(λ₁) p(λ₂)  p(λ_a) \n\nwhere the second sum is over all compositions λ of n into a parts. I found this formula in the Proof of Lemma 2.4 in Craven (2006).\n\nReferences\n\nCraven, D. (2006). The Number of t-Cores of Size n. http://web.mat.bham.ac.uk/D.A.Craven/docs/papers/tcores0608.pdf\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/multipartitions/#Operations","page":"Multipartitions","title":"Operations","text":"","category":"section"},{"location":"combinatorics/multipartitions/","page":"Multipartitions","title":"Multipartitions","text":"sum(::Multipartition{T}) where T<:Integer","category":"page"},{"location":"combinatorics/multipartitions/#Base.sum-Union{Tuple{Multipartition{T}}, Tuple{T}} where T<:Integer","page":"Multipartitions","title":"Base.sum","text":"sum(P::Multipartition{T}) where T<:Integer\n\nIf P is a multipartition of the integer n, this function returns n.\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/compositions/#Compositions","page":"Compositions","title":"Compositions","text":"","category":"section"},{"location":"combinatorics/compositions/","page":"Compositions","title":"Compositions","text":"Composition","category":"page"},{"location":"combinatorics/compositions/#JuLie.Composition","page":"Compositions","title":"JuLie.Composition","text":"Composition{T<:Integer} <: AbstractArray{T,1}\n\nA composition (also called ordered partition) of an integer n ≥ 0 is a sequence (λ₁,…,λₖ) of positive integers λᵢ whose sum is equal to n. The λᵢ are called the parts of the composition.\n\nExamples\n\njulia> c=Composition([2,1])\n[2, 1]\njulia> sum(c)\n3\njulia> c[1]\n2\n\nReferences\n\nWikipedia, Composition (combinatorics)\nBóna, M. (2017). A Walk Through Combinatorics (Fourth Edition). World Scientific.\n\n\n\n\n\n","category":"type"},{"location":"combinatorics/compositions/#Unrestricted-compositions","page":"Compositions","title":"Unrestricted compositions","text":"","category":"section"},{"location":"combinatorics/compositions/","page":"Compositions","title":"Compositions","text":"Compositions\ncompositions(::Integer)\nnum_compositions(::Integer)","category":"page"},{"location":"combinatorics/compositions/#JuLie.Compositions","page":"Compositions","title":"JuLie.Compositions","text":"struct Compositions{T<:Integer}\n\nReturns an iterator over all compositions of an integer n. The iterator simply iterates over compositions of n into k parts for 1 ≤ k ≤ n using CompositionsFixedNumParts.\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"combinatorics/compositions/#JuLie.compositions-Tuple{Integer}","page":"Compositions","title":"JuLie.compositions","text":"compositons(n::Integer)\n\nReturns the full list of compositions of n using the Compositions iterator.\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/compositions/#JuLie.num_compositions-Tuple{Integer}","page":"Compositions","title":"JuLie.num_compositions","text":"num_compositions(n::Integer)\n\nThe number of compositions of an integer n  0 is equal to\n\nleftlbrace beginarrayll\n    1  textif  n = 0 \n    2^n-1  textif  n  1 \nendarray right\n\nSee Corollary 5.4 of Bóna (2017).\n\nReferences\n\nThe On-Line Encyclopedia of Integer Sequences, A011782\nBóna, M. (2017). A Walk Through Combinatorics (Fourth Edition). World Scientific.\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/compositions/#Restricted-compositions","page":"Compositions","title":"Restricted compositions","text":"","category":"section"},{"location":"combinatorics/compositions/","page":"Compositions","title":"Compositions","text":"compositions(::Integer,::Integer)\nnum_compositions(::Integer,::Integer)","category":"page"},{"location":"combinatorics/compositions/#JuLie.compositions-Tuple{Integer,Integer}","page":"Compositions","title":"JuLie.compositions","text":"compositons(n::Integer, k::Integer)\n\nReturns the full list of compositions of n into k parts using the CompositionsFixedNumParts iterator.\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/compositions/#JuLie.num_compositions-Tuple{Integer,Integer}","page":"Compositions","title":"JuLie.num_compositions","text":"num_compositions(n::Integer, k::Integer)\n\nThe number of compositions of an integer n  0 into k  0 parts is equal to\n\nleftlbrace beginarrayll\n    1  textif  n=k=0 \n    n-1 choose k-1  textotherwise \nendarray right\n\nSee Corollary 5.3 of Bóna (2017).\n\nReferences\n\nBóna, M. (2017). A Walk Through Combinatorics (Fourth Edition). World Scientific.\n\n\n\n\n\n","category":"method"},{"location":"algebraic-structures/jucat/#Tensor-categories:-JuCat","page":"Tensor categories: JuCat","title":"Tensor categories: JuCat","text":"","category":"section"},{"location":"algebraic-structures/jucat/","page":"Tensor categories: JuCat","title":"Tensor categories: JuCat","text":"There is a new package under development called JuCat which implements structures and algorithms around tensor categories.","category":"page"},{"location":"about/integer-types/#integer-types","page":"Integer types","title":"Integer types","text":"","category":"section"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"There are various integer types in Julia. On the one hand there are integer types with a fixed number of bits ranging from 8-bit integers Int8 to 128-bit integers Int128. The default integer type Int will be Int64 (on a 64-bit machine). Moreover, there is BigInt for arbitrary precision integers. Finally, there is a union type Integer encompassing all the various integer types.","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"We are not done yet with the integer types. The Nemo package (which is part of the OSCAR system) introduces another arbitrary precision integer type fmpz (with shortcut constructor ZZ) from the FLINT library:","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"julia> ZZ(2)^64\n18446744073709551616\n\njulia> typeof(ZZ(2))\nNemo.fmpz","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"warning: Warning\nIn JuLie we will use fmpz instead of BigInt.","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"There are various reasons why Nemo/OSCAR (and thus JuLie) prefers fmpz: this type is more efficient as it scales between machine integers and big integers; it is better to \"own\" the integer type when doing exact computer algebra because some Julia functions don't really do what we expect as algebraists (for example the determinant function det from the LinearAlgebra package returns a float for a matrix consisting of Int64 integers); the ring ℤ itself is implemented as a structure in Nemo/OSCAR and the  fmpz integers really live in this ring, which reflects the mathematics more accurately:","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"julia> parent(ZZ(2))\nInteger Ring","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"Some mathematical functions in Julia/OSCAR working on integers will return an integer of the same type as they received but this is not completely consistent:","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"julia> typeof(factorial(10)) #factorial(21) will cause an overflow error\nInt64\n\njulia> typeof(factorial(Int8(10)))\nInt64 #Not Int8!\n\njulia> typeof(factorial(ZZ(10))) #factorial(ZZ(21)) no problem\nNemo.fmpz","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"warning: Warning\nAlways be aware of (and careful with) the integer types you pass to a function and that you get back.","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"As an algebraist, you would be one the safe side by always using fmpz. But having the possibility to use smaller integer types is actually very useful because if you're sure that smaller integer types are sufficient and never overflow in what you intend to do, this will increase performance and consume less memory. In JuLie we have therefore often implemented parametric types depending on an integer type which allow you to do this. For example, for partitions we have a parametric type Partition{T} where T is a subtype of Integer (the union type of all integer types in Julia) and this allows you to do:","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"julia> P=Partition(Int8[2,1])\nInt8[2, 1]","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"We have created the partition (2,1) of 3 using 8-bit integers. Compare this to constructing the partition with the default integer type:","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"julia> P=Partition([2,1])\n[2, 1]","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"It's basically the same thing but the former will consume less memory which will be important when dealing with millions of partitions. But you need to be careful when doing arithmetic with the components of a partition because this may overflow—and if it does there will be no warning by Julia!","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"Now, functions dealing with partitions can work with smaller integer types as well:","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"julia> partitions(Int8(3))\n3-element Vector{Partition{Int8}}:\n Int8[3]\n Int8[2, 1]\n Int8[1, 1, 1]","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"compared to","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"julia> partitions(3)\n3-element Vector{Partition{Int64}}:\n [3]\n [2, 1]\n [1, 1, 1]","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"Let's summarize:","category":"page"},{"location":"about/integer-types/","page":"Integer types","title":"Integer types","text":"warning: Advice and warning\nUse smaller integer types to your advantage but be careful to not cause overflows in your computations.","category":"page"},{"location":"about/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Contributions are necessary and very much welcome! Here is some help on how to do this. This section is written for those who are very new to developing in Julia, so you may skip many things—but please at least read the programming and documenting guidelines.","category":"page"},{"location":"about/contributing/#Setting-up-the-repository","page":"Contributing","title":"Setting up the repository","text":"","category":"section"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"If you have previously installed JuLie as described in the installation section of the manual, you should remove it first to get a clean environment for developing: in Julia, hit the ] key to enter the Pkg mode, type rm JuLie, and exit Julia.","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Everything around version control will be handled by Git and you need to have this installed. A quick introduction to Git is here. To contribute, it's best to have a GitHub account and fork my JuLie.jl repository. Clone your fork to somewhere on your computer:","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"git clone https://github.com/YOUR_USERNAME/JuLie.jl","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Enter the directory JuLie.jl of your clone, start Julia, hit the ] key, and then register the package at this location for developing by typing","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"dev .","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Exit the Pkg mode by hitting the backspace key. Then you can start using the package as usual with:","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"using JuLie","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"The idea of working with Git is that for any reasonable chunk of changes you do in the source code, you fix the state by doing a Git commit (with a reasonable description). Remeber to first add every new file via git add. As a commit is only a local thing, you need to eventually push all your commits to your repository on GitHub. If you're asked for your GitHub username and passwort at every push, then here is some advice on how to stop this.","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"To merge your repository into the official one, you do a pull request on GitHub. But before you do this, please make sure that everything is well-documented, the documentation builds correctly, and all tests pass.","category":"page"},{"location":"about/contributing/#Structure-of-JuLie","page":"Contributing","title":"Structure of JuLie","text":"","category":"section"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"JuLie is composed of three parts: the sources, the tests, and the documentation. The source files are located in the src directory. The main source file is src/JuLie.jl. Three things are happening here:","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Importing structures and functions from other packages. Imports are done one by one instead of doing a full import of everything from, e.g., OSCAR, to keep JuLie slick and have maximal control. All these structures and functions can be used directly in the JuLie code. If necessary, you may add more imports here (as long as you're developing and haven't finally decided on what you actually need, put the new imports in the source file you're working on first).\nExporting structures and functions. This only concerns exports of some of the imports above and this is done for convenience so that, e.g., one can directly create a polynomial ring from within JuLie without having to load AbstractAlgebra or Nemo first. The exports of functions implemented in JuLie itself are located in the various source files.\nInclusion of all the various source files of JuLie.","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"To ensure proper functionality of JuLie we use unit testing. The directory test contains various test sets, and these are combined in the file runtests.jl. You can run a single test set by, e.g., julia runtests.jl combinatorics/partitions.jl, and you can run the full unit test with Pkg.test(\"JuLie\") in Julia.","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"The documentation is automatically built on GitHub using the package Documenter.jl from the comments in the source files together with the Markdown files in the docs/src directory. The file docs/make.jl defines the structure of the navigation panel. You can build the documentation locally by running julia make.jl local; the result is then in the build directory.","category":"page"},{"location":"about/contributing/#Programming","page":"Contributing","title":"Programming","text":"","category":"section"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"If you are completely new to Julia, you should read the introduction section. Eventually, you will need to look things up in the official Julia documentation. It will be helpful to browse through some of the source files of JuLie to get a quick impression of the programming style. Here are some guidelines:","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"We follow the official Julia style guide.\nUnicode in the source code is allowed and encouraged to increase readability. The LaTex-like abbreviations for unicode characters can be used in, e.g., the Atom editor with the latex-completions package.\nWe use everything from OSCAR that is useful for us.\nMathematical structures you implement should somehow reflect how they are defined and treated abstractly. This is often easier said than done and one really needs to think about this before implementing anything.\nIf your implementation is not faster than those in other computer algebra systems then it's not good enough. (Don't take this too seriously, but at least try. A not incredibly fast algorithm is better than no algorithm at all, especially if the structures are mathematically sound so that we can improve functions at a later stage without having to do structural changes). Please read the Julia performance guide to not fall into typical traps.\nFor every function you implement, you should add a reasonable test to the unit testing. Try to find computed examples in publications or which follow from general theory etc.","category":"page"},{"location":"about/contributing/#Documenting","page":"Contributing","title":"Documenting","text":"","category":"section"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Everything has to be well-documented, algorithms and papers have to be properly referenced. Here are some guidelines:","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Add comments in the code to explain what you're doing.\nTo express mathematics in the documentation we use unicode, and for the more complicated things we combine this with LaTeX. Here's an example of how this is done:\n@doc raw\"\"\"\n\tquantum_integer(n::Int, q::RingElem)\nLet ``n ∈ ℤ`` and let ``ℚ(𝐪)`` be the fraction field of the polynomial ring ``ℤ[𝐪]``...\n\"\"\"\nfunction quantum_integer(n::Int, q::RingElem)\n    ...\nend\nEverything between the `` is interpreted as LaTex. You can add similar comments for structures. The comments can be integrated in the documentation by adding the function (or structure) name to the Markdown files in the docs/src directory.\nWe use an \"Examples\" section in the documentation block to give some examples.\nWe use a \"References\" section at the end of a documentation block to list references. The references are given in APA style, e.g. \"Etingof, P. & Ginzburg, V. (2002). Symplectic reflection algebras, Calogero-Moser space, and deformed Harish-Chandra homomorphism. Invent. Math., 147(2), 243–348. https://doi.org/10.1007/s002220100171\". In-text references in APA style look like \"Etingof & Ginzburg (2002)\". You can use BibDesk and the APA export template to save time dealing with this.","category":"page"},{"location":"about/contributing/#The-Revise-package","page":"Contributing","title":"The Revise package","text":"","category":"section"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"If you have a running Julia session with JuLie loaded, then changes you make to the JuLie code will have no effect in the running Julia session—you have to restart it. This is simply the way Julia works. But this is annoying when developing. A solution is to use the Revise package. You can install it with","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.add(\"Revise\")","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"and then you need to load it before loading the package you're working on:","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"using Revise\nusing JuLie","category":"page"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"Now, changes you make in the code are immediately available in the running Julia session (except for changes to structures, here you still need to restart).","category":"page"},{"location":"about/contributing/#The-BenchmarkTools-package","page":"Contributing","title":"The BenchmarkTools package","text":"","category":"section"},{"location":"about/contributing/","page":"Contributing","title":"Contributing","text":"You can measure the execution time of a command by using the @time macro. But this is not ideal because this measure a lot of overhead as well like just-in-time compilation. For proper benchmarking you can use the BenchmarkTools package.","category":"page"},{"location":"algebraic-structures/oscar/#OSCAR","page":"Basic algebraic structures: OSCAR","title":"Basic algebraic structures: OSCAR","text":"","category":"section"},{"location":"algebraic-structures/oscar/","page":"Basic algebraic structures: OSCAR","title":"Basic algebraic structures: OSCAR","text":"The goal of the OSCAR project (which is short for Open Source Computer Algebra Research) is to develop a modern, high-performance, mathematically sound computer algebra system based on Julia and integrating existing computer algebra systems. Part of the OSCAR ecosystem are the following Julia packages:","category":"page"},{"location":"algebraic-structures/oscar/","page":"Basic algebraic structures: OSCAR","title":"Basic algebraic structures: OSCAR","text":"AbstractAlgebra.jl: generic algebraic structures in pure Julia (like a general type of rings and of polynomial rings over a ring).\nNemo.jl: very fast arithmetic for special rings (like the integers and polynomial rings over the integers)—often based on the FLINT library.\nHecke.jl: algebraic number theory.\nGAP.jl: GAP integration.\nSingular.jl: Singular integration.\nOscar.jl: high-level package combining and extending the above.","category":"page"},{"location":"algebraic-structures/oscar/","page":"Basic algebraic structures: OSCAR","title":"Basic algebraic structures: OSCAR","text":"JuLie may be considered as a further contribution to the OSCAR project and in particular integrates with and builds upon this ecosystem. Here is an overview of basic algebraic structures from OSCAR that are used in JuLie (see here for the full list of imports):","category":"page"},{"location":"algebraic-structures/oscar/","page":"Basic algebraic structures: OSCAR","title":"Basic algebraic structures: OSCAR","text":"Big integers of type fmpz (with shortcut ZZ) from Nemo, e.g. ZZ(5). We prefer this to BigInt because it is what is used in Nemo and is faster.\nBig exact rationals of type fmpq (with shortcut QQ) from Nemo, e.g. QQ(5//3) or ZZ(5)//ZZ(3).\nFinite fields from Nemo, e.g. R, x = FiniteField(7, 3, \"x\") creates the field of characteristic 7 and of degree 3 over the prime field (i.e. having 7³=343 elements) and with primitive element x.\nCyclotomic fields from Nemo, e.g. K,z = CyclotomicField(3, \"z\").\nUnivariant polynomial rings, e.g. R, x = PolynomialRing(ZZ, \"x\") creates the  univariate polynomial ring over the integers with indeterminate x. This is implemented generically in AbstractAlgebra but there are special types for rings optimized in Nemo.\nMultivariate polynomial rings, e.g. R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"]) creates the multivariate polynomial ring over the integers with indeterminates x and y. Again, there are special types for rings optimized in Nemo.\nUnivariate Laurent polynomial rings, e.g. R, x = LaurentPolynomialRing(ZZ, \"x\").\nMatrices, e.g. M = matrix(ZZ, [3 1 2; 2 0 1]). Again, there are special types for rings optimized in Nemo.\nVector spaces, e.g. VectorSpace(QQ, 2), and free modules, e.g. FreeModule(ZZ, 3).","category":"page"},{"location":"about/benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"about/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Here is an overview of timings of some benchmarks to show how JuLie compares to other computer algebra systems. It's not meant to belittle anyone—but as one of the goals of JuLie is being fast, we need to verify that we're on track. All the timings are in seconds, short descriptions are given below, and you can find program files for the various systems in the bench directory of the JuLie repository. If you find a mistake, please message me.","category":"page"},{"location":"about/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Benchmark JuLie Sage GAP Magma\nCompositions 3.69 145 50.6 —\nPartitions 4.13 185 50.7 32.9\nSemistandard tableaux 4.08 233 — —\nStandard tableaux 3.00 385 — —","category":"page"},{"location":"about/benchmarks/#Descriptions","page":"Benchmarks","title":"Descriptions","text":"","category":"section"},{"location":"about/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Compositions: Creating the list of compositions of the integer 26. There are about 33.5 million.\nPartitions: Creating the list of partitions of the integer 90. There are about 56.6 million.\nSemistandard tableaux: Creating the list of semistandard tableaux of shape (6,3,2). There are about 17 million.\nStandard tableaux: Creating the list of standard tableaux of shape (10,8,3). There are about 7.9 million.","category":"page"},{"location":"combinatorics/permutations/#Permutations","page":"Permutations","title":"Permutations","text":"","category":"section"},{"location":"combinatorics/permutations/","page":"Permutations","title":"Permutations","text":"Permutation","category":"page"},{"location":"combinatorics/permutations/#JuLie.Permutation","page":"Permutations","title":"JuLie.Permutation","text":"Permutation{T<:Integer}\n\nA permutation of a set X is a bijection X → X.\n\n\n\n\n\n","category":"type"},{"location":"#JuLie","page":"JuLie","title":"JuLie","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"JuLie is an early-stage package for the programming language Julia with the goal of providing mathematically sound structures and fast algorithms for things around representation theory, especially algebraic Lie theory and accompanying combinatorics. These fields are huge and this package is still small—hopefully it will grow with time. Contributions are necessary and very much welcome!","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"By Ulrich Thiel (University of Kaiserslautern) and contributors.","category":"page"},{"location":"#Installation","page":"JuLie","title":"Installation","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"You first need to install Julia (this works on any operating system). Then after starting Julia, type the following to install this package:","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/ulthiel/JuLie.jl\")","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"Now, you can start using JuLie by typing:","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"julia> using JuLie","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"Here's an example:","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"julia> partitions(3)\n3-element Vector{Partition{Int64}}:\n [3]\n [2, 1]\n [1, 1, 1]\njulia> @time partitions(Int8(90)); #One goal of JuLie is being fast :-)\n  5.723798 seconds (56.63 M allocations: 4.529 GiB, 25.55% gc time)","category":"page"},{"location":"#Acknowledgments","page":"JuLie","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"This work is a contribution to the SFB-TRR 195 'Symbolic Tools in Mathematics and their Application' of the German Research Foundation (DFG). I thank everyone who contributed (see below). The logo shows the root system of type G₂ and is taken from Wikipedia.","category":"page"},{"location":"#Contributors","page":"JuLie","title":"Contributors","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"Max Horn (TU Kaiserslautern, 2020): Julia generalities\nTom Schmit (TU Kaiserslautern, 2020–2021): Cartan matrices, Coxeter groups (Casselman I algorithm), Documenter.jl and GitHub integration, Kostka polynomials, Schur polynomials, Tableaux\nElisa Thiel (2020): De-gotoing old ALGOL code","category":"page"},{"location":"combinatorics/multiset-partitions/#Multiset-partitions","page":"Multiset partitions","title":"Multiset partitions","text":"","category":"section"},{"location":"combinatorics/multiset-partitions/","page":"Multiset partitions","title":"Multiset partitions","text":"Multiset_partition\nmultiset_partitions","category":"page"},{"location":"combinatorics/multiset-partitions/#JuLie.Multiset_partition","page":"Multiset partitions","title":"JuLie.Multiset_partition","text":"Multiset_partition{T}\n\nMultiset-partitions are generalizations of partitions. An r-component multiset-partition of an integer n is a multiset(a set where each element can be contained multiple times) of partitions λ¹ λ²  λʳ where each λⁱ is a partition of some integer nᵢ  1 and the nᵢ sum to n. As for partitions, we have implemented an own type Multiset_partition{T}. As with partitions, you can can use smaller integer types to increase performance.\n\nExample\n\njulia> P = Multiset_partition( [2,1], [4], [3,2,1] )\n{[2, 1], [4], [3, 2, 1]}\njulia> sum(P)\n13\njulia> Multiset_partition( Array{Int8,1}[[2,1], [4], [3,2,1]] ) #Using 8-bit integers\n{Int8[2, 1], Int8[4], Int8[3, 2, 1]}\n\nSince Multiset-partitions are unordered sets, you can't call an explicit element, however, you can iterate over a Multiset_partition.\n\nExample\n\njulia> MSP = Multiset_partition( [2,1], [4], [3,2,1] )\n{[2, 1], [4], [3, 2, 1]}\njulia> for p in MSP println(p) end\n[2, 1]\n[4]\n[3, 2, 1]\n\n\n\n\n\n","category":"type"},{"location":"combinatorics/multiset-partitions/#JuLie.multiset_partitions","page":"Multiset partitions","title":"JuLie.multiset_partitions","text":"multiset_partitions(n::T) where T<:Integer\n\nA list of all multiset_partitions of an integer n  0.\n\nThe performance will suffer by casting n into a smaller integer type, e.g.\n\nmultiset_partitions(Int8(20))\n\n\n\n\n\nmultiset_partitions(p::Partition{T})\twhere T<:Integer\n\nA list of all possible multiset_partitions of a Partition, by regrouping its parts into Partitions.\n\nThe algorithm used is the algorithm M by , \"The Art of Computer Programming - Volume 4A, Combinatorial Algorithms, Part 1\" by Donald E. Knuth(2011), 429–430. De-gotoed, index-shifted and generalized.\n\n\n\n\n\nmultiset_partitions(n::T, r::Integer) where T<:Integer\n\nA list of all multiset_partitions of an integer n  0 into r  1 parts.\n\n\n\n\n\nmultiset_partitions(p::Partition{T}, r::Integer) where T<:Integer\n\nA list of all possible r-restricted multiset_partitions of a Partition, by regrouping its parts into Partitions.\n\nThe algorithm used is a version of the algorithm M by , \"The Art of Computer Programming - Volume 4A, Combinatorial Algorithms, Part 1\" by Donald E. Knuth, 429–430 http://www.cs.utsa.edu/~wagner/knuth/fasc3b.pdf. De-gotoed, index-shifted and generalized.\n\n\n\n\n\n","category":"function"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Partitions · JuLie</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuLie logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuLie</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">About</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">JuLie</a></li><li><a class="tocitem" href="../../about/motivation/">Motivation</a></li><li><a class="tocitem" href="../../about/julia-intro/">Introduction to Julia</a></li><li><a class="tocitem" href="../../about/integer-types/">Integer types</a></li><li><a class="tocitem" href="../../about/contributing/">Contributing</a></li><li><a class="tocitem" href="../../about/benchmarks/">Benchmarks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Algebraic structures</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../algebraic-structures/oscar/">Basic algebraic structures: OSCAR</a></li><li><a class="tocitem" href="../../algebraic-structures/jucat/">Tensor categories: JuCat</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../permutations/">Permutations</a></li></ul></li><li><a class="tocitem" href="../../julie-index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Partitions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Partitions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ulthiel/JuLie.jl/blob/master/docs/src/combinatorics/partitions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Partitions"><a class="docs-heading-anchor" href="#Partitions">Partitions</a><a id="Partitions-1"></a><a class="docs-heading-anchor-permalink" href="#Partitions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="JuLie.Partition" href="#JuLie.Partition"><code>JuLie.Partition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Partition{T} &lt;: AbstractArray{T,1}</code></pre><p>A <strong>partition</strong> of an integer n ≥ 0 is a decreasing sequence λ=(λ₁,…,λᵣ) of positive integers λᵢ whose sum is equal to n. The λᵢ are called the <strong>parts</strong> of the partition. We encode a partition as an array with elements λᵢ. You may increase performance by using smaller integer types, see the examples below. For efficiency, the <code>Partition</code> constructor does not check whether the given array is in fact a partition, i.e. a decreasing sequence.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; P=Partition([3,2,1]) #The partition 3+2+1 of 6
[3, 2, 1]
julia&gt; sum(P) #The sum of the parts.
6
julia&gt; P[1] #First component
3
julia&gt; P=Partition(Int8[3,2,1]) #Same partition but using 8 bit integers</code></pre><p><strong>Remarks</strong></p><ul><li><p>Usually, |λ| ≔ n is called the <strong>size</strong> of λ. In Julia, the function <code>size</code> for arrays already exists and returns the <em>dimension</em> of an array. Instead, you can use the Julia function <code>sum</code> to get the sum of the parts.</p></li><li><p>There is no performance impact by using an own type for partitions rather than simply using arrays—and this is of course much cleaner. The implementation of a subtype of AbstractArray is explained in the <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array">Julia documentation</a>.</p></li></ul><p><strong>References</strong></p><ol><li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (number theory)</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L9-L33">source</a></section></article><h2 id="Unrestricted-partitions"><a class="docs-heading-anchor" href="#Unrestricted-partitions">Unrestricted partitions</a><a id="Unrestricted-partitions-1"></a><a class="docs-heading-anchor-permalink" href="#Unrestricted-partitions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.partitions-Tuple{Integer}" href="#JuLie.partitions-Tuple{Integer}"><code>JuLie.partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitions(n::Integer)</code></pre><p>A list of all partitions of an integer n ≥ 0, produced in lexicographically <em>descending</em> order. This ordering is like in Sage, but opposite to GAP. You can apply the function <code>reverse</code> to reverse the order. As usual, you may increase performance by using smaller integer types. The algorithm used is &quot;Algorithm ZS1&quot; by Zoghbi &amp; Stojmenovic (1998).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; partitions(Int8(10)) #Using 8-bit integers</code></pre><p><strong>References</strong></p><ol><li>Zoghbi, A. &amp; Stojmenovic, I. (1998). Fast algorithms for generating integer partitions. <em>Int. J. Comput. Math., 70</em>(2), 319–332. <a href="https://doi.org/10.1080/00207169808804755">https://doi.org/10.1080/00207169808804755</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L171-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.num_partitions-Tuple{Integer}" href="#JuLie.num_partitions-Tuple{Integer}"><code>JuLie.num_partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_partitions(n::Integer)
num_partitions(n::fmpz)</code></pre><p>The number of integer partitions of the integer n ≥ 0. Uses the function from FLINT, which is very fast.</p><p><strong>References</strong></p><ol><li>The On-Line Encyclopedia of Integer Sequences, <a href="https://oeis.org/A000041">A000041</a></li><li>FLINT, <a href="http://flintlib.org/doc/arith.html?highlight=partitions#number-of-partitions">Number of partitions</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L93-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.ascending_partitions" href="#JuLie.ascending_partitions"><code>JuLie.ascending_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ascending_partitions(n::Integer;alg=&quot;ks&quot;)</code></pre><p>Instead of encoding a partition of an integer n ≥ 0 as a <em>descending</em> sequence (which is our convention), one can also encode it as an <em>ascending</em> sequence. In the papers Kelleher &amp; O&#39;Sullivan (2014) and Merca (2012) it is said that generating the list of all ascending partitions is more efficient than generating descending ones. To test this, I have implemented the algorithms given in the papers:</p><ol><li>&quot;ks&quot; (<em>default</em>) is the algorithm &quot;AccelAsc&quot; (Algorithm 4.1) in Kelleher &amp; O&#39;Sullivan (2014).</li><li>&quot;m&quot; is Algorithm 6 in Merca (2012). This is actually similar to &quot;ks&quot;.</li></ol><p>The ascending partitions are stored here as arrays and are not of type <code>Partition</code> since the latter are descending by our convention. I am using &quot;ks&quot; as default since it looks slicker and I believe there is a tiny mistake in the publication of &quot;m&quot; (which I fixed).</p><p><strong>Comparison</strong></p><p>I don&#39;t see a significant speed difference to the descending encoding:</p><pre><code class="language-julia-repl">julia&gt; @btime partitions(Int8(90));
    3.376 s (56634200 allocations: 6.24 GiB)

julia&gt; @btime ascending_partitions(Int8(90),alg=&quot;ks&quot;);
    3.395 s (56634200 allocations: 6.24 GiB)

julia&gt; @btime ascending_partitions(Int8(90),alg=&quot;m&quot;);
    3.451 s (56634200 allocations: 6.24 GiB)</code></pre><p><strong>References</strong></p><ol><li><p>Kelleher, J. &amp; B., O&#39;Sullivan (2014). Generating All Partitions: A Comparison Of Two Encodings. <em>arXiv:0909.2331v2</em>. <a href="https://arxiv.org/abs/0909.2331">https://arxiv.org/abs/0909.2331</a></p></li><li><p>Merca, M. (2012). Fast algorithm for generating ascending compositions. <em>J. Math. Model. Algorithms, 11</em>(1), 89–104. <a href="https://doi.org/10.1007/s10852-011-9168-y">https://doi.org/10.1007/s10852-011-9168-y</a></p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L238-L266">source</a></section></article><h2 id="Restricted-partitions"><a class="docs-heading-anchor" href="#Restricted-partitions">Restricted partitions</a><a id="Restricted-partitions-1"></a><a class="docs-heading-anchor-permalink" href="#Restricted-partitions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.partitions-NTuple{4,Integer}" href="#JuLie.partitions-NTuple{4,Integer}"><code>JuLie.partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitions(m::Integer, n::Integer, l1::Integer, l2::Integer; z=0)</code></pre><p>A list of all partitions of an integer m ≥ 0 into n ≥ 0 parts with lower bound l1 ≥ 0 and upper bound l2 ≥ l1 for the parts. There are two choices for the parameter z:</p><ul><li>z=0: no further restriction (<em>default</em>);</li><li>z=1: only distinct parts.</li></ul><p>The partitions are produced in <em>decreasing</em> order.</p><p>The algorithm used is &quot;parta&quot; in Riha &amp; James (1976), de-gotoed from old ALGOL code by E. Thiel!</p><p><strong>References</strong></p><ol><li>Riha, W. &amp; James, K. R. (1976). Algorithm 29 efficient algorithms for doubly and multiply restricted partitions. <em>Computing, 16</em>, 163–168. <a href="https://link.springer.com/article/10.1007/BF02241987">https://link.springer.com/article/10.1007/BF02241987</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L372-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.partitions-Tuple{Integer,Integer}" href="#JuLie.partitions-Tuple{Integer,Integer}"><code>JuLie.partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitions(m::Integer, n::Integer)</code></pre><p>All partitions of an integer m ≥ 0 into n ≥ 1 parts (no further restrictions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L482-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.num_partitions-Tuple{Integer,Integer}" href="#JuLie.num_partitions-Tuple{Integer,Integer}"><code>JuLie.num_partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_partitions(n::Integer, k::Integer)
num_partitions(n::fmpz, k::fmpz)</code></pre><p>The number of integer partitions of the integer n ≥ 0 into k ≥ 0 parts. The implementation uses a recurrence relation.</p><p><strong>References</strong></p><ol><li>The On-Line Encyclopedia of Integer Sequences, <a href="https://oeis.org/A008284">A008284</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.partitions-Tuple{Array{Integer,1},Integer,Array{Integer,1},Integer}" href="#JuLie.partitions-Tuple{Array{Integer,1},Integer,Array{Integer,1},Integer}"><code>JuLie.partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitions(mu::Array{Integer,1}, m::Integer, v::Array{Integer,1}, n::Integer)</code></pre><p>All partitions of an integer m &gt;= 0 into n &gt;= 1 parts, where each part is an element in v and each v[i] occurs a maximum of mu[i] times. The partitions are produced in    <em>decreasing</em> order. The algorithm used is a de-gotoed version (by E. Thiel!) of algorithm &quot;partb&quot; in Riha &amp; James (1976).</p><p><strong>Remark</strong></p><p>The original algorithm lead to BoundsErrors, since r could get smaller than 1. Furthermore x and y are handled as arrays with an infinite length. After finding all valid partitions, the algorithm will continue searching for partitions of length n+1. We thus had to add a few additional checks and interruptions. Done by T. Schmit.</p><p><strong>References</strong></p><ol><li>Riha, W. &amp; James, K. R. (1976). Algorithm 29 efficient algorithms for doubly and multiply restricted partitions. <em>Computing, 16</em>, 163–168. <a href="https://link.springer.com/article/10.1007/BF02241987">https://link.springer.com/article/10.1007/BF02241987</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L493-L503">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.conjugate" href="#JuLie.conjugate"><code>JuLie.conjugate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">conjugate(λ::Partition{T}) where T&lt;:Integer</code></pre><p>The <strong>conjugate</strong> of a partition is obtained by considering its Young diagram (see <a href="../tableaux/#Tableaux">Tableaux</a>) and then flipping it along its main diagonal.</p><p><strong>References</strong></p><ol><li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Partition_(number_theory)#Conjugate_and_self-conjugate_partitions">Partition (number theory)</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L665-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.getindex_safe" href="#JuLie.getindex_safe"><code>JuLie.getindex_safe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getindex_safe(P::Partition, i::Int)</code></pre><p>In algorithms involving partitions it is sometimes convenient to be able to access parts beyond the length of the partition, and then you want to get zero instead of an error. This function is a shortcut for</p><pre><code class="language-none">return (i&gt;length(P.p) ? 0 : getindex(P.p,i))</code></pre><p>If you are sure that <code>P[i]</code> exists, use <code>getindex</code> because this will be faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L79-L87">source</a></section></article><h2 id="Relations"><a class="docs-heading-anchor" href="#Relations">Relations</a><a id="Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Relations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.dominates" href="#JuLie.dominates"><code>JuLie.dominates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dominates(λ::Partition, μ::Partition)</code></pre><p>The <strong>dominance order</strong> on partitions is the partial order ⊵ defined by λ ⊵ μ if and only if λ₁ + … + λᵢ ≥ μ₁ + … + μᵢ for all i. This function returns true if λ ⊵ μ.</p><p><strong>References</strong></p><ol><li>Wikipedia, <a href="https://en.wikipedia.org/wiki/Dominance_order">Dominance order</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ulthiel/JuLie.jl/blob/bf882f1e43a9e937de6f73fec1cd3416f54b52fb/src/combinatorics/partitions.jl#L634-L641">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 March 2022 11:39">Wednesday 16 March 2022</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JuLie.jl ¬∑ JuLie Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JuLie Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>JuLie.jl</a><ul class="internal"><li><a class="tocitem" href="#Using"><span>Using</span></a></li><li><a class="tocitem" href="#Partitions"><span>Partitions</span></a></li><li><a class="tocitem" href="#Tableaux"><span>Tableaux</span></a></li><li><a class="tocitem" href="#Kostka-Polynomials"><span>Kostka Polynomials</span></a></li><li><a class="tocitem" href="#Schur-Polynomials"><span>Schur Polynomials</span></a></li><li><a class="tocitem" href="#Enumerative-functions"><span>Enumerative functions</span></a></li><li><a class="tocitem" href="#Quantum-numbers"><span>Quantum numbers</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>JuLie.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>JuLie.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/schto223/JuLie.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JuLie.jl"><a class="docs-heading-anchor" href="#JuLie.jl">JuLie.jl</a><a id="JuLie.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JuLie.jl" title="Permalink"></a></h1><p>An early-stage <a href="https://julialang.org">Julia</a>/<a href="https://oscar.computeralgebra.de">OSCAR</a> package for things around algebraic Lie theory, representation theory, and relevant combinatorics. Contributions are very much welcome!</p><p>By Ulrich Thiel (<a href="https://ulthiel.com/math">ulthiel.com/math</a>) and contributors.</p><h2 id="Using"><a class="docs-heading-anchor" href="#Using">Using</a><a id="Using-1"></a><a class="docs-heading-anchor-permalink" href="#Using" title="Permalink"></a></h2><p>To install the package, do the following In Julia:</p><pre><code class="language-none">using Pkg
Pkg.add(url=&quot;https://github.com/ulthiel/JuLie.jl&quot;)</code></pre><p>Then you can start using the package as follows:</p><pre><code class="language-none">using JuLie
partitions(10)</code></pre><p>You can get a list of exported functions using</p><pre><code class="language-none">names(JuLie)</code></pre><p>You can get help for a function by putting a question mark in front, e.g.</p><pre><code class="language-none">?partitions</code></pre><h2 id="Partitions"><a class="docs-heading-anchor" href="#Partitions">Partitions</a><a id="Partitions-1"></a><a class="docs-heading-anchor-permalink" href="#Partitions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.Partition" href="#JuLie.Partition"><code>JuLie.Partition</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Partition{T} &lt;: AbstractArray{T,1}</code></pre><p>A <strong>partition</strong> of an integer <span>$n \geq 0$</span> is a <em>decreasing</em> (our convention) sequence <span>$n_1, n_2, \ldots$</span> of positive integers whose sum is equal to <span>$n$</span>. You can create a partition with</p><pre><code class="language-none">P=Partition([3,2,1])</code></pre><p>and then work with it like with an array. In fact, Partition is a subtype of AbstractArray{T,1}. You can increase performance by using smaller integer types, e.g.</p><pre><code class="language-none">P=Partition(Int8[3,2,1])</code></pre><p>Note that for efficiency the Partition constructor does not check whether the given array is in fact a partition, i.e. a decreasing sequence. That&#39;s your job.</p><p><strong>Remark.</strong> I was thinking back and forth whether to implement an own structure for this because it&#39;s actually just an array of integers. But it makes sense since we have several functions just acting on partitons and it would be strange implementing them for arrays in general (where mostly they don&#39;t make sense). I was hesitating because I feared that an own structure for partitions will have a performance impact. But it does not! In my standard example creating the partitions of 90 there is really NO difference in runtime and memory consumption between using arrays and using an own structure.</p><p>The implementation of a subtype of AbstractArray is explained in <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array">the Julia documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L11-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.getelement" href="#JuLie.getelement"><code>JuLie.getelement</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getelement(P::Partition, i::Int)</code></pre><p>returns the <span>$i$</span>-th Element of <span>$P$</span>, if <span>$i &gt; length(P)$</span> this returns 0 instead of throwing an Exception.</p><p>If you are sure that <span>$P[i]$</span> exists, use <strong>getindex</strong> which is faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.dominates" href="#JuLie.dominates"><code>JuLie.dominates</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dominates(lambda::Partition, mu::Partition)</code></pre><p>returns true if <span>$lambda ‚â• mu$</span> according to the dominance order on partitions:</p><p><span>$Œª ‚â• Œº :‚ü∫   Œª[1] + ... + Œª[i] ‚â• Œº[1] + ... + Œº[i]$</span> for all <span>$i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L507-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.conjugate" href="#JuLie.conjugate"><code>JuLie.conjugate</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">conjugate(p::Partition{T}) where T&lt;:Integer</code></pre><p>returns the <strong>conjugate</strong> partition of <span>$p$</span>.</p><p>The <strong>conjugate</strong> of a partition <span>$p$</span> is obtained by writing <span>$p$</span> as a <strong>diagram</strong> and then flipping it along it&#39;s main diagonal.</p><p>For more information see: <a href="https://en.wikipedia.org/wiki/Partition_(number_theory)#Conjugate_and_self-conjugate_partitions">Wikipedia:Partition</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L537-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.partitions" href="#JuLie.partitions"><code>JuLie.partitions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partitions(n::Integer)</code></pre><p>A list of all partitions of an integer <span>$n ‚â• 0$</span>, produced in lexicographically <em>descending</em> order (like in SAGE, but opposite to GAP (you can apply reverse() to reverse the order)).</p><p>The algorithm used is the algorithm ZS1 by A. Zoghbi and I. Stojmenovic, &quot;Fast algorithms for generating integer partitions&quot;, Int. J. Comput. Math. 70 (1998), no. 2, 319‚Äì332.</p><p>You can increase performance by casting <span>$n$</span> into a smaller integer type, e.g.</p><pre><code class="language-none">partitions(Int8(90))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L72-L83">source</a></section><section><div><pre><code class="language-none">partitions(m::Integer, n::Integer, l1::Integer, l2::Integer; z=0)</code></pre><p>All partitions of an integer <span>$m ‚â• 0$</span> into <span>$n ‚â• 0$</span> parts with lower bound <span>$l1 ‚â• 0$</span> and upper bound <span>$l2 ‚â• l1$</span>. Parameter <span>$z$</span> should be set to 0 for arbitrary choice of parts (<em>default</em>), 1 for distinct parts. The partitions are produced in  <em>decreasing</em> order.</p><p>The algorithm used is &quot;parta&quot; by W. Riha and K. R. James, &quot;Algorithm 29. Efficient Algorithms for Doubly and Multiply Restricted Partitions&quot; (1976). De-gotoed from ALGOL code by Elisa!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L266-L272">source</a></section><section><div><pre><code class="language-none">partitions(m::Integer, n::Integer)</code></pre><p>All partitions of an integer <span>$m ‚â• 0$</span> into <span>$n ‚â• 1$</span> parts (no further restrictions). This simply calls <code>partitions(m,n,1,m,z=0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.ascending_partitions" href="#JuLie.ascending_partitions"><code>JuLie.ascending_partitions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ascending_partitions(n::Integer;alg=&quot;ks&quot;)</code></pre><p>Instead of encoding a partition of an integer <span>$n ‚â• 0$</span> as a descending sequence (which is our convention), one can also encode it as an <em>ascending</em> sequence. In the papers below it is claimed that generating the list of all ascending partitions is more efficient than generating descending ones. To test this, I have implemented the algorithms:</p><ol><li>&quot;ks&quot; (<em>default</em>) is the algorithm AccelAsc (Algorithm 4.1) by J. Kelleher and B. O&#39;Sullivan, &quot;Generating All Partitions: A Comparison Of Two Encodings&quot;, https://arxiv.org/pdf/0909.2331.pdf, May 2014.</li><li>&quot;m&quot; is Algorithm 6 by M. Merca, &quot;Fast Algorithm for Generating Ascending Compositions&quot;, J. Math Model. Algor. (2012) 11:89‚Äì104. This is similar to &quot;ks&quot;.</li></ol><p>The ascending partitions are given here as arrays, not of type Partition since these are descending by convention.</p><p>I don&#39;t see a significant speed difference to the descending encoding:</p><pre><code class="language-none">julia&gt; @btime partitions(Int8(90));
  3.376 s (56634200 allocations: 6.24 GiB)

julia&gt; @btime ascending_partitions(Int8(90),alg=&quot;ks&quot;);
  3.395 s (56634200 allocations: 6.24 GiB)

julia&gt; @btime ascending_partitions(Int8(90),alg=&quot;m&quot;);
  3.451 s (56634200 allocations: 6.24 GiB)</code></pre><p>I am using &quot;ks&quot; as default since it looks slicker and I believe there is a tiny mistake in the publication of &quot;m&quot; (which I fixed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/partitions.jl#L138-L159">source</a></section></article><h3 id="Multipartitions"><a class="docs-heading-anchor" href="#Multipartitions">Multipartitions</a><a id="Multipartitions-1"></a><a class="docs-heading-anchor-permalink" href="#Multipartitions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuLie.Multipartition" href="#JuLie.Multipartition"><code>JuLie.Multipartition</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Multipartition{T} &lt;: AbstractArray{Partition{T},1}</code></pre><p>An <span>$r$</span>-component <strong>multipartition</strong> of an integer <span>$n$</span> is an <span>$r$</span>-tuple of partitions <span>$\lambda^{(1)},...,\lambda^{(r)}$</span> where each <span>$\lambda^{(i)}$</span> is a partition of some <span>$a_i$</span> and the <span>$a_i$</span> sum to <span>$n$</span>.</p><p>You can create a multipartition with</p><pre><code class="language-none">Multipartition( [[2,1], [], [3,2,1]] )</code></pre><p>As with partitions, you can cast into smaller integer types to increase performance:</p><pre><code class="language-none">Multipartition( Array{Int8,1}[[2,1], [], [3,2,1]] )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multipartitions.jl#L9-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.multipartitions" href="#JuLie.multipartitions"><code>JuLie.multipartitions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function multipartitions(n::T, r::Integer) where T&lt;:Integer</code></pre><p>A list of all <span>$r$</span>-component multipartitions of <span>$n$</span>. As for partitions, you can cast <span>$n$</span> into smaller type for efficiency, e.g.</p><pre><code class="language-none">multipartitions(Int8(3),2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multipartitions.jl#L55-L62">source</a></section></article><h3 id="Multiset_partitions"><a class="docs-heading-anchor" href="#Multiset_partitions">Multiset_partitions</a><a id="Multiset_partitions-1"></a><a class="docs-heading-anchor-permalink" href="#Multiset_partitions" title="Permalink"></a></h3><p>A <strong>Multiset_partition</strong> is a Multipartition <span>$Œª^{(1)},...,Œª^{(r)}$</span> where each <span>$\lambda^{(i)}$</span> is a non-empty partition.<span>$\\$</span> Furthermore the ordering of the Partitions <span>$\lambda^{(i)}$</span> is not important, i.e. <span>$\lambda^{(1)},...,\lambda^{(r)}$</span>=<span>$\lambda^{(\sigma(1))},...,\lambda^{(\sigma(r))}$</span> <span>$\\$</span> <strong>Note:</strong> This equality-relation is not implemented in this Module.</p><article class="docstring"><header><a class="docstring-binding" id="JuLie.multiset_partitions" href="#JuLie.multiset_partitions"><code>JuLie.multiset_partitions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multiset_partitions(n::T) where T&lt;:Integer</code></pre><p>A list of all multiset_partitions of an integer <span>$n ‚ãù 0$</span>.</p><p>The performance will suffer by casting <span>$n$</span> into a smaller integer type, e.g.</p><pre><code class="language-none">multiset_partitions(Int8(20))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multiset_partitions.jl#L37-L46">source</a></section><section><div><pre><code class="language-none">multiset_partitions(p::Partition{T})  where T&lt;:Integer</code></pre><p>A list of all possible multiset_partitions of a Partition, by regrouping its parts into Partitions.</p><p>The algorithm used is the algorithm M by , <a href="http://www.cs.utsa.edu/~wagner/knuth/fasc3b.pdf">&quot;The Art of Computer Programming - Volume 4A, Combinatotial Algorithms, Part 1&quot;</a> by Donald E. Knuth(2011), 429‚Äì430. De-gotoed, index-shifted and generalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multiset_partitions.jl#L68-L74">source</a></section><section><div><pre><code class="language-none">multiset_partitions(n::T, r::Integer) where T&lt;:Integer</code></pre><p>A list of all multiset_partitions of an integer <span>$n ‚ãù 0$</span> into <span>$r ‚ãù 1$</span> parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multiset_partitions.jl#L188-L192">source</a></section><section><div><pre><code class="language-none">multiset_partitions(p::Partition{T}, r::Integer) where T&lt;:Integer</code></pre><p>A list of all possible <span>$r$</span>-restricted multiset_partitions of a Partition, by regrouping its parts into Partitions.</p><p>The algorithm used is a version of the algorithm M by , &quot;The Art of Computer Programming - Volume 4A, Combinatotial Algorithms, Part 1&quot; by Donald E. Knuth, 429‚Äì430 http://www.cs.utsa.edu/~wagner/knuth/fasc3b.pdf. De-gotoed, index-shifted and generalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multiset_partitions.jl#L218-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.partition_to_partcount" href="#JuLie.partition_to_partcount"><code>JuLie.partition_to_partcount</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partition_to_partcount(p::Partition{T})  where T&lt;:Integer</code></pre><p>returns the <strong>part-count</strong> representation of a partition <span>$p$</span>, where the <span>$n$</span>-th element is the count of appearances of <span>$n$</span> in <span>$p$</span>.</p><pre><code class="language-none">julia&gt; partition_to_partcount([5,3,3,3,2,1,1])
  5-element Array{Int64,1}:
  2
  1
  3
  0
  1</code></pre><p>for performance, partitions with trailing zeroes will not be allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multiset_partitions.jl#L340-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.partcount_to_partition" href="#JuLie.partcount_to_partition"><code>JuLie.partcount_to_partition</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partcount_to_partition(pc::Array{T,1}) where T&lt;:Integer</code></pre><p>returns the partition from a part-count representation <span>$pc$</span> of a partition.</p><pre><code class="language-none">julia&gt; partcount_to_partition([2,0,1])
  [3,1,1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/multiset_partitions.jl#L375-L383">source</a></section></article><h2 id="Tableaux"><a class="docs-heading-anchor" href="#Tableaux">Tableaux</a><a id="Tableaux-1"></a><a class="docs-heading-anchor-permalink" href="#Tableaux" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.Tableau" href="#JuLie.Tableau"><code>JuLie.Tableau</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Tableau{T} &lt;: AbstractArray{AbstractArray{T,1},1}</code></pre><p>A <strong>tableau</strong> or Young tableau is a finite collection of boxes, each holding a value. The boxes are arranged in left-justified rows. These rows are read from top to bottom. The row lengths have to be non-increasing order. You can create a tableau with</p><pre><code class="language-none">Tab=Tableau([[1,2,3],[4,5],[6]])</code></pre><p>and then work with it like with an array of arrays. In fact, Tableau is a subtype of  AbstractArray{AbstractArray{T,1},1}. Note that for efficiency the Tableau constructor does not check whether the given array is in fact a Tableau, i.e. a sequence of Arrays with decreasing lenghts. That&#39;s your job. The implementation of a subtype of AbstractArray is explained in <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array">the Julia documentation</a>.</p><p>Furthermore there are two spezial types of tableaux:</p><p>A <strong>semistandard tableaux</strong> is a tableaux where the values are non decreasing in each row, and strictly increasing in each column.</p><p>A <strong>standard tableaux</strong> is a tableaux where the values are strictly increasing in each row and column. A standard tableaux also requires each Integer from 1 to the amount of boxes to occur exactly once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L10-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.shape" href="#JuLie.shape"><code>JuLie.shape</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shape(Tab::Tableau{T})</code></pre><p>returns the shape of <span>$Tab$</span> as a Partition</p><p>The <strong>shape</strong> of a Tableau describes the length of each row. i.e:</p><pre><code class="language-none">julia&gt; shape([ [1,2,3,4], [5,6], [7] ])
  [4, 2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.weight" href="#JuLie.weight"><code>JuLie.weight</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">weight(Tab::Tableau)</code></pre><p>returns the <strong>weight</strong> of the tableau <span>$Tab$</span>.</p><p>i.e. <span>$w$</span>::Array{Int,1} such that <span>$w[i]$</span> = number of appearances of <span>$i$</span> in <span>$Tab$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L586-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.reading_word" href="#JuLie.reading_word"><code>JuLie.reading_word</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reading_word(Tab::Tableau)</code></pre><p>returns an Array containing the cells of <span>$Tab$</span> read from left to right and from bottom to top.</p><pre><code class="language-none">julia&gt; reading_word([ [1,2,3] , [4,5] , [6] ])
6-element Array{Int64,1}:
 6
 4
 5
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L611-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.hook_length" href="#JuLie.hook_length"><code>JuLie.hook_length</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hook_length(Tab::Tableau, i::Integer, j::Integer)</code></pre><p>returns the <strong>hook length</strong> of <span>$Tab[i][j]$</span>.</p><p>The <strong>hook length</strong> of a cell, is the count of cells to the right in the same row + the count of cells below in the same column + 1</p><p>assumes that <span>$Tab[i][j]$</span> exists</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L525-L533">source</a></section><section><div><pre><code class="language-none">hook_length(s::Partition, i::Integer, j::Integer)</code></pre><p>returns the <strong>hook length</strong> of <span>$Tab[i][j]$</span> for a Tableau <span>$Tab$</span> of shape <span>$s$</span>.</p><p>assumes that <span>$i‚â§length(s)$</span> and <span>$j‚â§s[i]$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L546-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.hook_length_formula" href="#JuLie.hook_length_formula"><code>JuLie.hook_length_formula</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hook_length_formula(s::Partition)</code></pre><p>returns the <strong>hook length formula</strong> for a tableau of shape <span>$s$</span>.</p><div>\[f^{Œª} = {\dfrac{n!}{‚àè h_Œª(i,j)}}\]</div><p>where the product is over all cells <span>$(i,j)$</span> in <span>$Tab$</span>, and <span>$h_Œª$</span> is the <a href="index.html#JuLie.hook_length">hook_length</a>.</p><p>Equals the number of standard tableaux of shape <span>$s$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L564-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.schensted" href="#JuLie.schensted"><code>JuLie.schensted</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">schensted(sigma::Array{Integer,1})</code></pre><p>An implementation of the Schensted algorithm from the Robinson-Schensted correspondence. <span>$sigma$</span> represents the second line of a Permutation in two-line notation: <span>$1-&gt;sigma[1] , 2-&gt;sigma[2] ,‚Ä¶$</span> Returns a pair of <strong>standard tableaux</strong> <span>$P,Q$</span> (insertion- and recording- tableaux)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L446-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.bump!" href="#JuLie.bump!"><code>JuLie.bump!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bump!(Tab::Tableau, x::Int)</code></pre><p>Inserts <span>$x$</span> into <span>$Tab$</span> according to the <a href="https://mathworld.wolfram.com/BumpingAlgorithm.html">Bumping algorithm</a> by applying the Schensted insertion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L464-L468">source</a></section><section><div><pre><code class="language-none">bump!(Tab::Tableau, x::Integer, Q::Tableau, y::Integer)</code></pre><p>Inserts <span>$x$</span> into <span>$Tab$</span> according to the <a href="https://mathworld.wolfram.com/BumpingAlgorithm.html">Bumping algorithm</a> by applying the Schensted insertion. Traces the change with <span>$Q$</span> by inserting <span>$y$</span> at the same Position in <span>$Q$</span> as <span>$x$</span> in <span>$Tab$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L492-L497">source</a></section></article><h3 id="semistandard-Tableaux"><a class="docs-heading-anchor" href="#semistandard-Tableaux">semistandard Tableaux</a><a id="semistandard-Tableaux-1"></a><a class="docs-heading-anchor-permalink" href="#semistandard-Tableaux" title="Permalink"></a></h3><p>A <strong>semistandard tableaux</strong> is a tableaux where the values are non decreasing in each row, and strictly increasing in each column.</p><article class="docstring"><header><a class="docstring-binding" id="JuLie.semistandard_tableaux" href="#JuLie.semistandard_tableaux"><code>JuLie.semistandard_tableaux</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">semistandard_tableaux(shape::Partition{T}, max_val=sum(shape)::Integer) where T&lt;:Integer</code></pre><p>returns an Array containing all <strong>semistandard tableaux</strong> of shape <span>$shape$</span> and elements <span>$‚â§ max\_val$</span>. The tableaux are in lexicographic order from left to right and top to bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L68-L73">source</a></section><section><div><pre><code class="language-none">semistandard_tableaux(shape::Array{T,1}, max_val=sum(shape)::Integer) where T&lt;:Integer</code></pre><p>returns an Array containing all <strong>semistandard tableaux</strong> of shape <span>$shape$</span> and elements <span>$‚â§ max\_val$</span>. The tableaux are in lexicographic order from left to right and top to bottom</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L79-L84">source</a></section><section><div><pre><code class="language-none">semistandard_tableaux(box_num::T, max_val=box_num::T) where T&lt;:Integer</code></pre><p>returns an Array containing all <strong>semistandard tableaux</strong> made from <span>$box\_num$</span> boxes and elements <span>$‚â§ max\_val$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L142-L146">source</a></section><section><div><pre><code class="language-none">semistandard_tableaux(s::Array{T,1}, weight::Array{T,1}) where T&lt;:Integer</code></pre><p>returns an Array containing all <strong>semistandard tableaux</strong> with shape <span>$s$</span> and weights <span>$weight$</span>.</p><p>requires that <span>$sum(s) = sum(weight)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L161-L167">source</a></section><section><div><pre><code class="language-none">semistandard_tableaux(s::Partition{T}, weight::Partition{T}) where T&lt;:Integer</code></pre><p>returns an Array containing all <strong>semistandard tableaux</strong> with shape <span>$s$</span> and weights <span>$weight$</span>.</p><p>requires that <span>$sum(s) = sum(weight)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L263-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.is_semistandard" href="#JuLie.is_semistandard"><code>JuLie.is_semistandard</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_semistandard(Tab::Tableau)</code></pre><p>Checks if <span>$Tab$</span> is a <strong>semistandard tableau</strong>. i.e. a Tableau with non decresing rows and strictly increasing columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L406-L410">source</a></section></article><h3 id="standard-Tableaux"><a class="docs-heading-anchor" href="#standard-Tableaux">standard Tableaux</a><a id="standard-Tableaux-1"></a><a class="docs-heading-anchor-permalink" href="#standard-Tableaux" title="Permalink"></a></h3><p>A <strong>standard tableaux</strong> is a tableaux where the values are strictly increasing in each row and column. A standard tableaux also requires each Integer from 1 to the amount of boxes to occur exactly once.</p><article class="docstring"><header><a class="docstring-binding" id="JuLie.standard_tableaux" href="#JuLie.standard_tableaux"><code>JuLie.standard_tableaux</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">standard_tableaux(s::Array{Integer,1})</code></pre><p>returns a list of all <strong>standard tableaux</strong> of a given shape <span>$s$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L275-L279">source</a></section><section><div><pre><code class="language-none">standard_tableaux(s::Partition)</code></pre><p>returns a list of all <strong>standard tableaux</strong> of a given shape <span>$s$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L285-L289">source</a></section><section><div><pre><code class="language-none">standard_tableaux(n::Integer)</code></pre><p>returns a list of all <strong>standard tableaux</strong> of size <span>$n$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L341-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.is_standard" href="#JuLie.is_standard"><code>JuLie.is_standard</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_standard(Tab::Tableau)</code></pre><p>Checks if <span>$Tab$</span> is a <strong>standard tableau</strong>. i.e. a Tableau with strictly increasing columns and rows, where each number from 1 to n appears exactly once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/tableaux.jl#L355-L359">source</a></section></article><h2 id="Kostka-Polynomials"><a class="docs-heading-anchor" href="#Kostka-Polynomials">Kostka Polynomials</a><a id="Kostka-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Kostka-Polynomials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.kostka_polynomial" href="#JuLie.kostka_polynomial"><code>JuLie.kostka_polynomial</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kostka_polynomial(lambda::Partition{T}, mu::Partition{T})</code></pre><p>returns the Kostka polynomial <span>$K_{lambda,mu}$</span> as a fmpz_poly over ZZ in t.</p><p>The Kostka polynomials are a Family of polynomials <span>$K_{ŒªŒº}$</span> relating <a href="https://en.wikipedia.org/wiki/Hall%E2%80%93Littlewood_polynomials">Hall-Littlewood polynomials</a> <span>$P_Œº$</span> to <a href="https://en.wikipedia.org/wiki/Schur_polynomial">Schur polynomials</a> <span>$s_Œª$</span> :</p><div>\[s_Œª(x_1,‚Ä¶,x_n) =\sum_Œº K_{ŒªŒº}(t)P_Œº(x_1,‚Ä¶,x_n;t)\]</div><p>They can be formulated as:</p><div>\[K_{ŒªŒº}(t) = ‚àë_{T ‚àà SSYT(Œª,Œº)} t^{charge(T)}\]</div><p>But I used the following fomula:</p><div>\[K_{Œª,Œº}(t)=‚àë_{\{v\}}‚àè_{K=1}^{l(Œª)-1}‚àè_{n‚â•1}
\begin{bmatrix}
‚Ñô_n^{(K)}+m_n(v^{(K)})\\
m_n(v^{(K)})
\end{bmatrix}_t\]</div><p>where the sum is over all admissible configurations <span>$\{v\}$</span> i.e. sequences of partitions <span>$v^{(K)}$</span> with</p><div>\[v^{(0)}=Œº \text{ ,\hspace{2mm} } |v^{(K)}|=‚àë_{j‚â•K+1}Œª_j \text{\hspace{5mm} and \hspace{5mm}} ‚Ñô_n^{(K)}‚â•0  \text{\hspace{2mm} for all \hspace{1mm}} n&gt;0, K=0,1,‚Ä¶l(Œª)\]</div><div>\[\begin{aligned}
&amp; ‚Ñô_n^{(K)} := ‚àë_{j‚â•1}\left[min\left(n,v_j^{(K+1)}\right) - 2‚ãÖmin\left(n,v_j^{(K)}\right) + min\left(n,v_j^{(K-1)}\right)\right]
\\
&amp; c(v) := ‚àë_{i‚â•1}(i-1)Œº_i + ‚àë_{K=1}^{l(Œª)-1}\left(ùïÑ\left[v^{(K)}, v^{(K)}\right] - ùïÑ\left[v^{(K)}, v^{(K-1)}\right]\right)
\\
&amp; ùïÑ[œÅ,Œ∫] := ‚àë_{i,j‚â•1} min(œÅ_i,Œ∫_j)
\end{aligned}\]</div><p><span>$\left[\genfrac{[}{]}{0pt}{0}{m}{n} \right]_t$</span> the <a href="https://en.wikipedia.org/wiki/Gaussian_binomial_coefficient">Gaussian binomial coefficient</a></p><p>The Algorithm is based on <a href="https://inspirehep.net/files/ab8568896dcce9b3115b76dc9d096da4">A matrix model for WZW</a> (Apendix B) by Nick Dorey, David Tonga and Carl Turner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/kostka_polynomials.jl#L13-L60">source</a></section><section><div><pre><code class="language-none">kostka_polynomial(lambda::Array{Integer,1}, mu::Array{Integer,1})</code></pre><p>Shortcut for <code>kostka_polynomial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/kostka_polynomials.jl#L207-L211">source</a></section></article><h2 id="Schur-Polynomials"><a class="docs-heading-anchor" href="#Schur-Polynomials">Schur Polynomials</a><a id="Schur-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Schur-Polynomials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.schur_polynomial" href="#JuLie.schur_polynomial"><code>JuLie.schur_polynomial</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">schur_polynomial(shp::Partition)</code></pre><p>returns the Schur function <span>$s_{shp}$</span> as a Multivariate Polynomial.</p><div>\[s_{shp}:=‚àë_{T} x_1^{m_1}‚Ä¶x_n^{m_n}\]</div><p>where the sum is taken over all <strong>semistandard tableaux</strong> <span>$T$</span> of shape <span>$shp$</span>, and <span>$m_i$</span> gives the weight of <span>$i$</span> in <span>$T$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/schur_polynomials.jl#L13-L23">source</a></section></article><h2 id="Enumerative-functions"><a class="docs-heading-anchor" href="#Enumerative-functions">Enumerative functions</a><a id="Enumerative-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Enumerative-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.num_partitions" href="#JuLie.num_partitions"><code>JuLie.num_partitions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_partitions(n::fmpz)
num_partitions(n::Integer)</code></pre><p>The number of integer partitions of the integer <span>$n ‚â• 0$</span>. Uses the function from FLINT, which is really fast.</p><p>For more information on these numbers, see <a href="https://oeis.org/A000041">OEIS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/enum_func.jl#L13-L20">source</a></section><section><div><pre><code class="language-none">num_partitions(n::fmpz, k::fmpz)
num_partitions(n::Integer, k::Integer)</code></pre><p>The number of integer partitions of the integer <span>$n ‚â• 0$</span> into <span>$k ‚â• 0$</span> parts. The implementation uses a recurrence relation.</p><p>For more information on these numbers, see <a href="https://oeis.org/A008284">OEIS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/enum_func.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.catalan" href="#JuLie.catalan"><code>JuLie.catalan</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">catalan(n::fmpz; alg=&quot;binomial&quot;)
catalan(n::Integer; alg=&quot;binomial&quot;)</code></pre><p>The n-th Catalan number. This counts a gazillion of things, see <a href="https://oeis.org/A000108">OEIS</a> for more information. There are two algorithms implemented:</p><ol><li>&quot;binomial&quot; (<em>default</em>): uses a simple formula with binomial coefficients.</li><li>&quot;iterative&quot;: uses an iterative computation.</li></ol><p>The binomial computation is much faster:</p><pre><code class="language-none">julia&gt; @time x=catalan( ZZ(10)^5 , alg=&quot;binomial&quot;);
 0.007727 seconds (9 allocations: 95.750 KiB)

julia&gt; @time x=catalan( ZZ(10)^5 , alg=&quot;iterative&quot;);
 1.572488 seconds (1.01 M allocations: 2.333 GiB, 1.36% gc time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/enum_func.jl#L98-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.stirling1" href="#JuLie.stirling1"><code>JuLie.stirling1</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stirling1(n::fmpz, k::fmpz)
stirling1(n::Integer, k::Integer)</code></pre><p>The Stirling number <span>$S_1(n,k)$</span> of the first kind. The absolute value of <span>$S_1(n,k)$</span> counts the number of permutations of <span>$n$</span> elements with <span>$k$</span> disjoint cycles. The implementation is a wrapper to the function in FLINT.</p><p>For more information on these numbers, see <a href="https://oeis.org/A008275">OEIS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/enum_func.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.stirling2" href="#JuLie.stirling2"><code>JuLie.stirling2</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stirling2(n::fmpz, k::fmpz)
stirling2(n::Integer, k::Integer)</code></pre><p>The Stirling number <span>$S_2(n,k)$</span> of the second kind. This counts the number of partitions of an <span>$n$</span>-set into <span>$k$</span> non-empty subsets. The implementation is a wrapper to the function in FLINT.</p><p>For more information on these numbers, see <a href="https://oeis.org/A008277">OEIS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/enum_func.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.lucas" href="#JuLie.lucas"><code>JuLie.lucas</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lucas(n::fmpz)
lucas(n::Integer)</code></pre><p>The n-th Lucas number. For more information on these numbers, see <a href="https://oeis.org/A000032">OEIS</a>. The implementation is a wrapper to the function in GMP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/enum_func.jl#L196-L201">source</a></section></article><h2 id="Quantum-numbers"><a class="docs-heading-anchor" href="#Quantum-numbers">Quantum numbers</a><a id="Quantum-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-numbers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuLie.quantum_number" href="#JuLie.quantum_number"><code>JuLie.quantum_number</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quantum_number(n::Int, q::RingElem)</code></pre><p>For an integer <span>$n \geq 0$</span> and a ring element <span>$q$</span> which is invertible in its parent ring, the quantum integer <span>$[n]_q$</span> is for <span>$n \geq 0$</span> defined as <span>$[n]_q = \sum_{i=0}^{n-1} q^{n-(2i+1)}$</span> and for <span>$n &lt; 0$</span> as <span>$[n]_q = -[-n]_q$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/quantum_numbers.jl#L13-L17">source</a></section><section><div><pre><code class="language-none">quantum_number(n::Int)</code></pre><p>The quantum number <span>$[n]_q$</span> where q is the interdeterminate of the Laurent polynomial ring <span>$\mathbb{Z}[q,q^{-1}]$</span> in one variable over the integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/quantum_numbers.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuLie.quantum" href="#JuLie.quantum"><code>JuLie.quantum</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quantum(n::Int, q::RingElem)</code></pre><p>This is a shortcut for <code>quanum_number(n,q)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/quantum_numbers.jl#L37-L41">source</a></section><section><div><pre><code class="language-none">quantum(n::Int)</code></pre><p>This is a shortcut for <code>quanum_number(n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/schto223/JuLie.jl/blob/7d7f335244bcd7a4c190ab74a6958f67f20a2e33/src/quantum_numbers.jl#L56-L60">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#JuLie.Multipartition"><code>JuLie.Multipartition</code></a></li><li><a href="#JuLie.Partition"><code>JuLie.Partition</code></a></li><li><a href="#JuLie.Tableau"><code>JuLie.Tableau</code></a></li><li><a href="#JuLie.ascending_partitions"><code>JuLie.ascending_partitions</code></a></li><li><a href="#JuLie.bump!"><code>JuLie.bump!</code></a></li><li><a href="#JuLie.catalan"><code>JuLie.catalan</code></a></li><li><a href="#JuLie.conjugate"><code>JuLie.conjugate</code></a></li><li><a href="#JuLie.dominates"><code>JuLie.dominates</code></a></li><li><a href="#JuLie.getelement"><code>JuLie.getelement</code></a></li><li><a href="#JuLie.hook_length"><code>JuLie.hook_length</code></a></li><li><a href="#JuLie.hook_length_formula"><code>JuLie.hook_length_formula</code></a></li><li><a href="#JuLie.is_semistandard"><code>JuLie.is_semistandard</code></a></li><li><a href="#JuLie.is_standard"><code>JuLie.is_standard</code></a></li><li><a href="#JuLie.kostka_polynomial"><code>JuLie.kostka_polynomial</code></a></li><li><a href="#JuLie.lucas"><code>JuLie.lucas</code></a></li><li><a href="#JuLie.multipartitions"><code>JuLie.multipartitions</code></a></li><li><a href="#JuLie.multiset_partitions"><code>JuLie.multiset_partitions</code></a></li><li><a href="#JuLie.num_partitions"><code>JuLie.num_partitions</code></a></li><li><a href="#JuLie.partcount_to_partition"><code>JuLie.partcount_to_partition</code></a></li><li><a href="#JuLie.partition_to_partcount"><code>JuLie.partition_to_partcount</code></a></li><li><a href="#JuLie.partitions"><code>JuLie.partitions</code></a></li><li><a href="#JuLie.quantum"><code>JuLie.quantum</code></a></li><li><a href="#JuLie.quantum_number"><code>JuLie.quantum_number</code></a></li><li><a href="#JuLie.reading_word"><code>JuLie.reading_word</code></a></li><li><a href="#JuLie.schensted"><code>JuLie.schensted</code></a></li><li><a href="#JuLie.schur_polynomial"><code>JuLie.schur_polynomial</code></a></li><li><a href="#JuLie.semistandard_tableaux"><code>JuLie.semistandard_tableaux</code></a></li><li><a href="#JuLie.shape"><code>JuLie.shape</code></a></li><li><a href="#JuLie.standard_tableaux"><code>JuLie.standard_tableaux</code></a></li><li><a href="#JuLie.stirling1"><code>JuLie.stirling1</code></a></li><li><a href="#JuLie.stirling2"><code>JuLie.stirling2</code></a></li><li><a href="#JuLie.weight"><code>JuLie.weight</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 December 2020 14:42">Tuesday 15 December 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

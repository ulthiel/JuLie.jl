var documenterSearchIndex = {"docs":
[{"location":"#JuLie.jl","page":"JuLie.jl","title":"JuLie.jl","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"An early-stage Julia/OSCAR package for things around algebraic Lie theory, representation theory, and relevant combinatorics. Contributions are very much welcome!","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"By Ulrich Thiel (ulthiel.com/math) and contributors.","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"CurrentModule = JuLie","category":"page"},{"location":"#Using","page":"JuLie.jl","title":"Using","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"To install the package, do the following In Julia:","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"using Pkg\r\nPkg.add(url=\"https://github.com/ulthiel/JuLie.jl\")","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"Then you can start using the package as follows:","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"using JuLie\r\npartitions(10)","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"You can get a list of exported functions using","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"names(JuLie)","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"You can get help for a function by putting a question mark in front, e.g.","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"?partitions","category":"page"},{"location":"#Partitions","page":"JuLie.jl","title":"Partitions","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"Partition\r\ngetelement\r\ndominates\r\nconjugate\r\npartitions\r\nascending_partitions","category":"page"},{"location":"#JuLie.Partition","page":"JuLie.jl","title":"JuLie.Partition","text":"struct Partition{T} <: AbstractArray{T,1}\n\nA partition of an integer n geq 0 is a decreasing (our convention) sequence n_1 n_2 ldots of positive integers whose sum is equal to n. You can create a partition with\n\nP=Partition([3,2,1])\n\nand then work with it like with an array. In fact, Partition is a subtype of AbstractArray{T,1}. You can increase performance by using smaller integer types, e.g.\n\nP=Partition(Int8[3,2,1])\n\nNote that for efficiency the Partition constructor does not check whether the given array is in fact a partition, i.e. a decreasing sequence. That's your job.\n\nRemark. I was thinking back and forth whether to implement an own structure for this because it's actually just an array of integers. But it makes sense since we have several functions just acting on partitons and it would be strange implementing them for arrays in general (where mostly they don't make sense). I was hesitating because I feared that an own structure for partitions will have a performance impact. But it does not! In my standard example creating the partitions of 90 there is really NO difference in runtime and memory consumption between using arrays and using an own structure.\n\nThe implementation of a subtype of AbstractArray is explained in the Julia documentation.\n\n\n\n\n\n","category":"type"},{"location":"#JuLie.getelement","page":"JuLie.jl","title":"JuLie.getelement","text":"getelement(P::Partition, i::Int)\n\nreturns the i-th Element of P, if i  length(P) this returns 0 instead of throwing an Exception.\n\nIf you are sure that Pi exists, use getindex which is faster.\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.dominates","page":"JuLie.jl","title":"JuLie.dominates","text":"dominates(lambda::Partition, mu::Partition)\n\nreturns true if lambda  mu according to the dominance order on partitions:\n\nÎ»  Î¼    Î»1 +  + Î»i  Î¼1 +  + Î¼i for all i\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.conjugate","page":"JuLie.jl","title":"JuLie.conjugate","text":"conjugate(p::Partition{T}) where T<:Integer\n\nreturns the conjugate partition of p.\n\nThe conjugate of a partition p is obtained by writing p as a diagram and then flipping it along it's main diagonal.\n\nFor more information see: Wikipedia:Partition\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.partitions","page":"JuLie.jl","title":"JuLie.partitions","text":"partitions(n::Integer)\n\nA list of all partitions of an integer n  0, produced in lexicographically descending order (like in SAGE, but opposite to GAP (you can apply reverse() to reverse the order)).\n\nThe algorithm used is the algorithm ZS1 by A. Zoghbi and I. Stojmenovic, \"Fast algorithms for generating integer partitions\", Int. J. Comput. Math. 70 (1998), no. 2, 319â€“332.\n\nYou can increase performance by casting n into a smaller integer type, e.g.\n\npartitions(Int8(90))\n\n\n\n\n\npartitions(m::Integer, n::Integer, l1::Integer, l2::Integer; z=0)\n\nAll partitions of an integer m  0 into n  0 parts with lower bound l1  0 and upper bound l2  l1. Parameter z should be set to 0 for arbitrary choice of parts (default), 1 for distinct parts. The partitions are produced in  decreasing order.\n\nThe algorithm used is \"parta\" by W. Riha and K. R. James, \"Algorithm 29. Efficient Algorithms for Doubly and Multiply Restricted Partitions\" (1976). De-gotoed from ALGOL code by Elisa!\n\n\n\n\n\npartitions(m::Integer, n::Integer)\n\nAll partitions of an integer m  0 into n  1 parts (no further restrictions). This simply calls partitions(m,n,1,m,z=0).\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.ascending_partitions","page":"JuLie.jl","title":"JuLie.ascending_partitions","text":"ascending_partitions(n::Integer;alg=\"ks\")\n\nInstead of encoding a partition of an integer n  0 as a descending sequence (which is our convention), one can also encode it as an ascending sequence. In the papers below it is claimed that generating the list of all ascending partitions is more efficient than generating descending ones. To test this, I have implemented the algorithms:\n\n\"ks\" (default) is the algorithm AccelAsc (Algorithm 4.1) by J. Kelleher and B. O'Sullivan, \"Generating All Partitions: A Comparison Of Two Encodings\", https://arxiv.org/pdf/0909.2331.pdf, May 2014.\n\"m\" is Algorithm 6 by M. Merca, \"Fast Algorithm for Generating Ascending Compositions\", J. Math Model. Algor. (2012) 11:89â€“104. This is similar to \"ks\".\n\nThe ascending partitions are given here as arrays, not of type Partition since these are descending by convention.\n\nI don't see a significant speed difference to the descending encoding:\n\njulia> @btime partitions(Int8(90));\n  3.376 s (56634200 allocations: 6.24 GiB)\n\njulia> @btime ascending_partitions(Int8(90),alg=\"ks\");\n  3.395 s (56634200 allocations: 6.24 GiB)\n\njulia> @btime ascending_partitions(Int8(90),alg=\"m\");\n  3.451 s (56634200 allocations: 6.24 GiB)\n\nI am using \"ks\" as default since it looks slicker and I believe there is a tiny mistake in the publication of \"m\" (which I fixed).\n\n\n\n\n\n","category":"function"},{"location":"#Multipartitions","page":"JuLie.jl","title":"Multipartitions","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"Multipartition\r\nmultipartitions","category":"page"},{"location":"#JuLie.Multipartition","page":"JuLie.jl","title":"JuLie.Multipartition","text":"struct Multipartition{T} <: AbstractArray{Partition{T},1}\n\nAn r-component multipartition of an integer n is an r-tuple of partitions lambda^(1)lambda^(r) where each lambda^(i) is a partition of some a_i and the a_i sum to n.\n\nYou can create a multipartition with\n\nMultipartition( [[2,1], [], [3,2,1]] )\n\nAs with partitions, you can cast into smaller integer types to increase performance:\n\nMultipartition( Array{Int8,1}[[2,1], [], [3,2,1]] )\n\n\n\n\n\n","category":"type"},{"location":"#JuLie.multipartitions","page":"JuLie.jl","title":"JuLie.multipartitions","text":"function multipartitions(n::T, r::Integer) where T<:Integer\n\nA list of all r-component multipartitions of n. As for partitions, you can cast n into smaller type for efficiency, e.g.\n\nmultipartitions(Int8(3),2)\n\n\n\n\n\n","category":"function"},{"location":"#Multiset_partitions","page":"JuLie.jl","title":"Multiset_partitions","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"A Multiset_partition is a Multipartition Î»^(1)Î»^(r) where each lambda^(i) is a non-empty partition. Furthermore the ordering of the Partitions lambda^(i) is not important, i.e. lambda^(1)lambda^(r)=lambda^(sigma(1))lambda^(sigma(r))  Note: This equality-relation is not implemented in this Module.","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"multiset_partitions\r\npartition_to_partcount\r\npartcount_to_partition","category":"page"},{"location":"#JuLie.multiset_partitions","page":"JuLie.jl","title":"JuLie.multiset_partitions","text":"multiset_partitions(n::T) where T<:Integer\n\nA list of all multiset_partitions of an integer n  0.\n\nThe performance will suffer by casting n into a smaller integer type, e.g.\n\nmultiset_partitions(Int8(20))\n\n\n\n\n\nmultiset_partitions(p::Partition{T})  where T<:Integer\n\nA list of all possible multiset_partitions of a Partition, by regrouping its parts into Partitions.\n\nThe algorithm used is the algorithm M by , \"The Art of Computer Programming - Volume 4A, Combinatotial Algorithms, Part 1\" by Donald E. Knuth(2011), 429â€“430. De-gotoed, index-shifted and generalized.\n\n\n\n\n\nmultiset_partitions(n::T, r::Integer) where T<:Integer\n\nA list of all multiset_partitions of an integer n  0 into r  1 parts.\n\n\n\n\n\nmultiset_partitions(p::Partition{T}, r::Integer) where T<:Integer\n\nA list of all possible r-restricted multiset_partitions of a Partition, by regrouping its parts into Partitions.\n\nThe algorithm used is a version of the algorithm M by , \"The Art of Computer Programming - Volume 4A, Combinatotial Algorithms, Part 1\" by Donald E. Knuth, 429â€“430 http://www.cs.utsa.edu/~wagner/knuth/fasc3b.pdf. De-gotoed, index-shifted and generalized.\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.partition_to_partcount","page":"JuLie.jl","title":"JuLie.partition_to_partcount","text":"partition_to_partcount(p::Partition{T})  where T<:Integer\n\nreturns the part-count representation of a partition p, where the n-th element is the count of appearances of n in p.\n\njulia> partition_to_partcount([5,3,3,3,2,1,1])\n  5-element Array{Int64,1}:\n  2\n  1\n  3\n  0\n  1\n\nfor performance, partitions with trailing zeroes will not be allowed.\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.partcount_to_partition","page":"JuLie.jl","title":"JuLie.partcount_to_partition","text":"partcount_to_partition(pc::Array{T,1}) where T<:Integer\n\nreturns the partition from a part-count representation pc of a partition.\n\njulia> partcount_to_partition([2,0,1])\n  [3,1,1]\n\n\n\n\n\n","category":"function"},{"location":"#Tableaux","page":"JuLie.jl","title":"Tableaux","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"Tableau\r\nshape\r\nweight\r\nreading_word\r\nhook_length\r\nhook_length_formula\r\nschensted\r\nbump!","category":"page"},{"location":"#JuLie.Tableau","page":"JuLie.jl","title":"JuLie.Tableau","text":"struct Tableau{T} <: AbstractArray{AbstractArray{T,1},1}\n\nA tableau or Young tableau is a finite collection of boxes, each holding a value. The boxes are arranged in left-justified rows. These rows are read from top to bottom. The row lengths have to be non-increasing order. You can create a tableau with\n\nTab=Tableau([[1,2,3],[4,5],[6]])\n\nand then work with it like with an array of arrays. In fact, Tableau is a subtype of  AbstractArray{AbstractArray{T,1},1}. Note that for efficiency the Tableau constructor does not check whether the given array is in fact a Tableau, i.e. a sequence of Arrays with decreasing lenghts. That's your job. The implementation of a subtype of AbstractArray is explained in the Julia documentation.\n\nFurthermore there are two spezial types of tableaux:\n\nA semistandard tableaux is a tableaux where the values are non decreasing in each row, and strictly increasing in each column.\n\nA standard tableaux is a tableaux where the values are strictly increasing in each row and column. A standard tableaux also requires each Integer from 1 to the amount of boxes to occur exactly once.\n\n\n\n\n\n","category":"type"},{"location":"#JuLie.shape","page":"JuLie.jl","title":"JuLie.shape","text":"shape(Tab::Tableau{T})\n\nreturns the shape of Tab as a Partition\n\nThe shape of a Tableau describes the length of each row. i.e:\n\njulia> shape([ [1,2,3,4], [5,6], [7] ])\n  [4, 2, 1]\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.weight","page":"JuLie.jl","title":"JuLie.weight","text":"weight(Tab::Tableau)\n\nreturns the weight of the tableau Tab.\n\ni.e. w::Array{Int,1} such that wi = number of appearances of i in Tab\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.reading_word","page":"JuLie.jl","title":"JuLie.reading_word","text":"reading_word(Tab::Tableau)\n\nreturns an Array containing the cells of Tab read from left to right and from bottom to top.\n\njulia> reading_word([ [1,2,3] , [4,5] , [6] ])\n6-element Array{Int64,1}:\n 6\n 4\n 5\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.hook_length","page":"JuLie.jl","title":"JuLie.hook_length","text":"hook_length(Tab::Tableau, i::Integer, j::Integer)\n\nreturns the hook length of Tabij.\n\nThe hook length of a cell, is the count of cells to the right in the same row + the count of cells below in the same column + 1\n\nassumes that Tabij exists\n\n\n\n\n\nhook_length(s::Partition, i::Integer, j::Integer)\n\nreturns the hook length of Tabij for a Tableau Tab of shape s.\n\nassumes that ilength(s) and jsi\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.hook_length_formula","page":"JuLie.jl","title":"JuLie.hook_length_formula","text":"hook_length_formula(s::Partition)\n\nreturns the hook length formula for a tableau of shape s.\n\nf^Î» = dfracn h_Î»(ij)\n\nwhere the product is over all cells (ij) in Tab, and h_Î» is the hook_length.\n\nEquals the number of standard tableaux of shape s\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.schensted","page":"JuLie.jl","title":"JuLie.schensted","text":"schensted(sigma::Array{Integer,1})\n\nAn implementation of the Schensted algorithm from the Robinson-Schensted correspondence. sigma represents the second line of a Permutation in two-line notation: 1-sigma1  2-sigma2  Returns a pair of standard tableaux PQ (insertion- and recording- tableaux)\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.bump!","page":"JuLie.jl","title":"JuLie.bump!","text":"bump!(Tab::Tableau, x::Int)\n\nInserts x into Tab according to the Bumping algorithm by applying the Schensted insertion.\n\n\n\n\n\nbump!(Tab::Tableau, x::Integer, Q::Tableau, y::Integer)\n\nInserts x into Tab according to the Bumping algorithm by applying the Schensted insertion. Traces the change with Q by inserting y at the same Position in Q as x in Tab.\n\n\n\n\n\n","category":"function"},{"location":"#semistandard-Tableaux","page":"JuLie.jl","title":"semistandard Tableaux","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"A semistandard tableaux is a tableaux where the values are non decreasing in each row, and strictly increasing in each column.","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"semistandard_tableaux\r\nis_semistandard","category":"page"},{"location":"#JuLie.semistandard_tableaux","page":"JuLie.jl","title":"JuLie.semistandard_tableaux","text":"semistandard_tableaux(shape::Partition{T}, max_val=sum(shape)::Integer) where T<:Integer\n\nreturns an Array containing all semistandard tableaux of shape shape and elements  max_val. The tableaux are in lexicographic order from left to right and top to bottom.\n\n\n\n\n\nsemistandard_tableaux(shape::Array{T,1}, max_val=sum(shape)::Integer) where T<:Integer\n\nreturns an Array containing all semistandard tableaux of shape shape and elements  max_val. The tableaux are in lexicographic order from left to right and top to bottom\n\n\n\n\n\nsemistandard_tableaux(box_num::T, max_val=box_num::T) where T<:Integer\n\nreturns an Array containing all semistandard tableaux made from box_num boxes and elements  max_val.\n\n\n\n\n\nsemistandard_tableaux(s::Array{T,1}, weight::Array{T,1}) where T<:Integer\n\nreturns an Array containing all semistandard tableaux with shape s and weights weight.\n\nrequires that sum(s) = sum(weight)\n\n\n\n\n\nsemistandard_tableaux(s::Partition{T}, weight::Partition{T}) where T<:Integer\n\nreturns an Array containing all semistandard tableaux with shape s and weights weight.\n\nrequires that sum(s) = sum(weight)\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.is_semistandard","page":"JuLie.jl","title":"JuLie.is_semistandard","text":"is_semistandard(Tab::Tableau)\n\nChecks if Tab is a semistandard tableau. i.e. a Tableau with non decresing rows and strictly increasing columns.\n\n\n\n\n\n","category":"function"},{"location":"#standard-Tableaux","page":"JuLie.jl","title":"standard Tableaux","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"A standard tableaux is a tableaux where the values are strictly increasing in each row and column. A standard tableaux also requires each Integer from 1 to the amount of boxes to occur exactly once.","category":"page"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"standard_tableaux\r\nis_standard","category":"page"},{"location":"#JuLie.standard_tableaux","page":"JuLie.jl","title":"JuLie.standard_tableaux","text":"standard_tableaux(s::Array{Integer,1})\n\nreturns a list of all standard tableaux of a given shape s\n\n\n\n\n\nstandard_tableaux(s::Partition)\n\nreturns a list of all standard tableaux of a given shape s\n\n\n\n\n\nstandard_tableaux(n::Integer)\n\nreturns a list of all standard tableaux of size n\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.is_standard","page":"JuLie.jl","title":"JuLie.is_standard","text":"is_standard(Tab::Tableau)\n\nChecks if Tab is a standard tableau. i.e. a Tableau with strictly increasing columns and rows, where each number from 1 to n appears exactly once.\n\n\n\n\n\n","category":"function"},{"location":"#Kostka-Polynomials","page":"JuLie.jl","title":"Kostka Polynomials","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"kostka_polynomial","category":"page"},{"location":"#JuLie.kostka_polynomial","page":"JuLie.jl","title":"JuLie.kostka_polynomial","text":"kostka_polynomial(lambda::Partition{T}, mu::Partition{T})\n\nreturns the Kostka polynomial K_lambdamu as a fmpz_poly over ZZ in t.\n\nThe Kostka polynomials are a Family of polynomials K_Î»Î¼ relating Hall-Littlewood polynomials P_Î¼ to Schur polynomials s_Î» :\n\ns_Î»(x_1x_n) =sum_Î¼ K_Î»Î¼(t)P_Î¼(x_1x_nt)\n\nThey can be formulated as:\n\nK_Î»Î¼(t) = _T  SSYT(Î»Î¼) t^charge(T)\n\nBut I used the following fomula:\n\nK_Î»Î¼(t)=_v_K=1^l(Î»)-1_n1\nbeginbmatrix\nâ„™_n^(K)+m_n(v^(K))\nm_n(v^(K))\nendbmatrix_t\n\nwhere the sum is over all admissible configurations v i.e. sequences of partitions v^(K) with\n\nv^(0)=Î¼ text hspace2mm  v^(K)=_jK+1Î»_j texthspace5mm and hspace5mm â„™_n^(K)0  texthspace2mm for all hspace1mm n0 K=01l(Î»)\n\nbeginaligned\n â„™_n^(K) = _j1leftminleft(nv_j^(K+1)right) - 2minleft(nv_j^(K)right) + minleft(nv_j^(K-1)right)right\n\n c(v) = _i1(i-1)Î¼_i + _K=1^l(Î»)-1left(ð•„leftv^(K) v^(K)right - ð•„leftv^(K) v^(K-1)rightright)\n\n ð•„ÏÎº = _ij1 min(Ï_iÎº_j)\nendaligned\n\nleftgenfrac0pt0mn right_t the Gaussian binomial coefficient\n\nThe Algorithm is based on A matrix model for WZW (Apendix B) by Nick Dorey, David Tonga and Carl Turner\n\n\n\n\n\nkostka_polynomial(lambda::Array{Integer,1}, mu::Array{Integer,1})\n\nShortcut for kostka_polynomial.\n\n\n\n\n\n","category":"function"},{"location":"#Schur-Polynomials","page":"JuLie.jl","title":"Schur Polynomials","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"schur_polynomial","category":"page"},{"location":"#JuLie.schur_polynomial","page":"JuLie.jl","title":"JuLie.schur_polynomial","text":"schur_polynomial(shp::Partition)\n\nreturns the Schur function s_shp as a Multivariate Polynomial.\n\ns_shp=_T x_1^m_1x_n^m_n\n\nwhere the sum is taken over all semistandard tableaux T of shape shp, and m_i gives the weight of i in T.\n\n\n\n\n\n","category":"function"},{"location":"#Enumerative-functions","page":"JuLie.jl","title":"Enumerative functions","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"num_partitions\r\ncatalan\r\nstirling1\r\nstirling2\r\nlucas","category":"page"},{"location":"#JuLie.num_partitions","page":"JuLie.jl","title":"JuLie.num_partitions","text":"num_partitions(n::fmpz)\nnum_partitions(n::Integer)\n\nThe number of integer partitions of the integer n  0. Uses the function from FLINT, which is really fast.\n\nFor more information on these numbers, see OEIS.\n\n\n\n\n\nnum_partitions(n::fmpz, k::fmpz)\nnum_partitions(n::Integer, k::Integer)\n\nThe number of integer partitions of the integer n  0 into k  0 parts. The implementation uses a recurrence relation.\n\nFor more information on these numbers, see OEIS.\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.catalan","page":"JuLie.jl","title":"JuLie.catalan","text":"catalan(n::fmpz; alg=\"binomial\")\ncatalan(n::Integer; alg=\"binomial\")\n\nThe n-th Catalan number. This counts a gazillion of things, see OEIS for more information. There are two algorithms implemented:\n\n\"binomial\" (default): uses a simple formula with binomial coefficients.\n\"iterative\": uses an iterative computation.\n\nThe binomial computation is much faster:\n\njulia> @time x=catalan( ZZ(10)^5 , alg=\"binomial\");\n 0.007727 seconds (9 allocations: 95.750 KiB)\n\njulia> @time x=catalan( ZZ(10)^5 , alg=\"iterative\");\n 1.572488 seconds (1.01 M allocations: 2.333 GiB, 1.36% gc time)\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.stirling1","page":"JuLie.jl","title":"JuLie.stirling1","text":"stirling1(n::fmpz, k::fmpz)\nstirling1(n::Integer, k::Integer)\n\nThe Stirling number S_1(nk) of the first kind. The absolute value of S_1(nk) counts the number of permutations of n elements with k disjoint cycles. The implementation is a wrapper to the function in FLINT.\n\nFor more information on these numbers, see OEIS.\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.stirling2","page":"JuLie.jl","title":"JuLie.stirling2","text":"stirling2(n::fmpz, k::fmpz)\nstirling2(n::Integer, k::Integer)\n\nThe Stirling number S_2(nk) of the second kind. This counts the number of partitions of an n-set into k non-empty subsets. The implementation is a wrapper to the function in FLINT.\n\nFor more information on these numbers, see OEIS.\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.lucas","page":"JuLie.jl","title":"JuLie.lucas","text":"lucas(n::fmpz)\nlucas(n::Integer)\n\nThe n-th Lucas number. For more information on these numbers, see OEIS. The implementation is a wrapper to the function in GMP.\n\n\n\n\n\n","category":"function"},{"location":"#Quantum-numbers","page":"JuLie.jl","title":"Quantum numbers","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"quantum_number\r\nquantum","category":"page"},{"location":"#JuLie.quantum_number","page":"JuLie.jl","title":"JuLie.quantum_number","text":"quantum_number(n::Int, q::RingElem)\n\nFor an integer n geq 0 and a ring element q which is invertible in its parent ring, the quantum integer n_q is for n geq 0 defined as n_q = sum_i=0^n-1 q^n-(2i+1) and for n  0 as n_q = --n_q.\n\n\n\n\n\nquantum_number(n::Int)\n\nThe quantum number n_q where q is the interdeterminate of the Laurent polynomial ring mathbbZqq^-1 in one variable over the integers.\n\n\n\n\n\n","category":"function"},{"location":"#JuLie.quantum","page":"JuLie.jl","title":"JuLie.quantum","text":"quantum(n::Int, q::RingElem)\n\nThis is a shortcut for quanum_number(n,q).\n\n\n\n\n\nquantum(n::Int)\n\nThis is a shortcut for quanum_number(n).\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"JuLie.jl","title":"Index","text":"","category":"section"},{"location":"","page":"JuLie.jl","title":"JuLie.jl","text":"","category":"page"}]
}
